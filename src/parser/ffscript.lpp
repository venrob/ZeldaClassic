/* -*- mode: bison; tab-width: 8 -*-
  use this file to generate lex.yy.c
  command: flex -B -olex.yy.cpp ffscript.lpp
*/

%option noyywrap
%option never-interactive

%x COMMENT
%x STRING
%x IMPORTING
%x IMPORTSTR
%s HASH

%{
#include <stdlib.h>
#include <sstream>
#include "AST.h"
#include "../zsyssimple.h"
#include "y.tab.hpp"
YYLTYPE noloc = {0,0,0,0};
int yyrow, yycol;

// Defined in ffscript.ypp.
void yymsg(std::string const& message, int row = yyrow, int col = yycol);
%}

%%

 /* Parser local code */
%{
using namespace ZScript;

int srow, scol;
std::ostringstream qstr;

#define NEWLINE ++yyrow; yycol = 1
#define ADVANCE yycol += yyleng

#define UPDATE_YYLLOC \
yylloc.first_line = yylloc.last_line = yyrow; \
yylloc.first_column = yycol; \
yycol += yyleng; \
yylloc.last_column = yycol

// Return token.
#define TOKEN(NAME) UPDATE_YYLLOC; return TOK_##NAME

// Return token and value.
#define VALUE(NAME, CONSTRUCTOR) \
UPDATE_YYLLOC; \
yylval = new CONSTRUCTOR; \
return TOK_##NAME

#define ESC_CHAR(CHAR) \
yycol += yyleng + 1; \
qstr << CHAR; \
break

#define TERMINATE \
BEGIN( INITIAL ); \
return 0
%}

 /* Keywords */
script		TOKEN( SCRIPT );
for		TOKEN( FOR );
if		TOKEN( IF );
else		TOKEN( ELSE );
switch		TOKEN( SWITCH );
case		TOKEN( CASE );
default		TOKEN( DEFAULT );
return		TOKEN( RETURN );
import		{
	BEGIN( IMPORTING ); //Handle the string following 'import' specially
	TOKEN( IMPORT );
}
true		TOKEN( ZTRUE );
false		TOKEN( ZFALSE );
while		TOKEN( WHILE );
global		TOKEN( GLOBAL );
break		TOKEN( BREAK );
continue	TOKEN( CONTINUE );
const		TOKEN( ZCONST );
do		TOKEN( DO );
typedef		TOKEN( TYPEDEF );
"#ignore error"		TOKEN( EXPECTERROR );
"#IGNORE ERROR"		TOKEN( EXPECTERROR );
"#ignore warning"	TOKEN( EXPECTERROR );
"#IGNORE WARNING"	TOKEN( EXPECTERROR );
OPTION_VALUE	TOKEN( OPTIONVALUE );
"#define"		TOKEN( DEFINE );
enum			TOKEN( ENUM );
namespace		TOKEN( NAMESPACE );
using			TOKEN( USING );

 /* Types */
void		TOKEN( ZVOID );
untyped		TOKEN( UNTYPED );
bool		TOKEN( ZBOOL );
float		TOKEN( ZFLOAT );
int		TOKEN( ZFLOAT );
bitmap		TOKEN( BITMAP );
cheat		TOKEN( CHEAT );
combodata	TOKEN( COMBO );
doorset		TOKEN( DOORSET );
dropset		TOKEN( DROPSET );
dmapdata	TOKEN( DMAP );
eweapon		TOKEN( EWEAPON );
ffc		TOKEN( FFC );
gamedata	TOKEN( GAMEDATA );
item		TOKEN( ITEM );
itemdata	TOKEN( ITEMCLASS );
lweapon		TOKEN( LWEAPON );
mapdata		TOKEN( MAP );
messagedata	TOKEN( MESSAGE );
misccolor	TOKEN( MISCCOLOR );
npc		TOKEN( NPC );
npcdata		TOKEN( NPCDATA );
palcycle	TOKEN( PALCYCLE );
palette		TOKEN( PALETTE );
ponddata	TOKEN( POND );
rgb		TOKEN( RGB );
shopdata	TOKEN( SHOP );
spritedata	TOKEN( SPRITE );
musicdata		TOKEN( TUNE );
warpring	TOKEN( WARPRING );
screendata	TOKEN( SCREEN );
player	TOKEN( PLAYER );
link	TOKEN( LINK );

 /* Syntax */
","		TOKEN( COMMA );
"."		TOKEN( DOT );
";"		TOKEN( SEMICOLON );
"::"	TOKEN( SCOPERES );
":"		TOKEN( COLON );
"("		TOKEN( LPAREN );
")"		TOKEN( RPAREN );
"["		TOKEN( LBRACKET );
"]"		TOKEN( RBRACKET );
"{"		TOKEN( LBRACE );
"}"		TOKEN( RBRACE );
"?"		TOKEN( QMARK ); //for ternary

 /* Operators (in order of operations) */
"->"		TOKEN( ARROW );
"++"		TOKEN( INCREMENT );
"--"		TOKEN( DECREMENT );
"!"		TOKEN( NOT );
"~"		TOKEN( BITNOT );
"*"		TOKEN( TIMES );
"/"		TOKEN( DIVIDE );
"%"		TOKEN( MODULO );
"+"		TOKEN( PLUS );
"-"		TOKEN( MINUS );
"<<"		TOKEN( LSHIFT );
">>"		TOKEN( RSHIFT );
"<"		TOKEN( LT );
"<="		TOKEN( LE );
">"		TOKEN( GT );
">="		TOKEN( GE );
"=="		TOKEN( EQ );
"!="		TOKEN( NE );
"&"		TOKEN( BITAND );
"^"		TOKEN( BITXOR );
"|"		TOKEN( BITOR );
"&&"		TOKEN( AND );
"||"		TOKEN( OR );
"="		TOKEN( ASSIGN );
"+="		TOKEN( PLUSASSIGN );
"-="		TOKEN( MINUSASSIGN );
"*="		TOKEN( TIMESASSIGN );
"/="		TOKEN( DIVIDEASSIGN );
"%="		TOKEN( MODULOASSIGN );
"<<="		TOKEN( LSHIFTASSIGN );
">>="		TOKEN( RSHIFTASSIGN );
"&="		TOKEN( BITANDASSIGN );
"^="		TOKEN( BITXORASSIGN );
"|="		TOKEN( BITORASSIGN );
"&&="		TOKEN( ANDASSIGN );
"||="		TOKEN( ORASSIGN );

 /* Line Comments */
"//".*		/* hit end of file */
"//".*\n	NEWLINE;

 /* Block Comments */
"/*"[^*\n]*			{
	srow = yyrow;
	scol = yycol;
	ADVANCE; 
	BEGIN( COMMENT );
}
<COMMENT>{
	[^*\n]*			ADVANCE;
	[^*\n]*\n		NEWLINE;
	"*"+[^*/\n]*		ADVANCE;
	"*"+[^*/\n]*\n		NEWLINE;
	"*"+"/"			ADVANCE; BEGIN( INITIAL );
	<<EOF>>			{
		yymsg("WARNING: Comment does not end.", srow, scol);
		TERMINATE;
	}
}

 /* Hash Commands */
<INITIAL>"#"		BEGIN( HASH ); TOKEN( HASH );
<HASH>{
	\\\n		NEWLINE;
	\n		NEWLINE; BEGIN( INITIAL ); TOKEN( ENDLINE );
	option		TOKEN( OPTION );
	inherit		TOKEN( INHERIT );
	on		TOKEN( ZTRUE );
	off		TOKEN( ZFALSE );
}

 /* Strings */
<INITIAL>\"		{
	BEGIN( STRING );
	qstr.str(""); /* Clear qstr */
	srow = yyrow;
	scol = yycol;
	ADVANCE;
}
<STRING>{
	<<EOF>>			{
		yymsg("ERROR: String does not end.", srow, scol);
		TERMINATE;
	}
	[^\"\n\\]*		ADVANCE; qstr << yytext;
	[^\"\n\\]*\n		NEWLINE; qstr << yytext;
	[^\"\n\\]*\\		{
		// Add the current text to the output, minus the \.
		yytext[yyleng - 1] = 0;
		qstr << yytext;
		// Read in the escaped character.
		register int c = yyinput();
		switch (c)
    {
			case 'a': ESC_CHAR('\a');
			case 'b': ESC_CHAR('\b');
			case 'f': ESC_CHAR('\f');
			case 'n': ESC_CHAR('\n');
			case 'r': ESC_CHAR('\r');
			case 't': ESC_CHAR('\t');
			case 'v': ESC_CHAR('\v');
			case '\n': NEWLINE; break;
			case 'x':
			{
				std::stringstream escstr;
				escstr.str("");
				int ch = yyinput();
				if((ch >= '0' && ch <= '9')||(ch>='a'&&ch<='f')||(ch>='A'&&ch<='F'))
					escstr << ((char)ch);
				else
				{
					yymsg("ERROR: Hex-insert escape code '\\x' has no value.", srow, scol);
					TERMINATE;
				}
				ch = yyinput();
				if((ch >= '0' && ch <= '9')||(ch>='a'&&ch<='f')||(ch>='A'&&ch<='F'))
					escstr << ((char)ch);
				else
				{
					unput(ch);
					//yymsg("ERROR: Hex-insert escape code '\\x' has one digit. These must have exactly two digits", srow, scol);
					//TERMINATE;
				}
				std::stringstream buf;
				int temp;
				buf << std::hex << escstr.str();
				buf >> temp;
				ESC_CHAR((char)temp);
			}
			case EOF:
				yymsg("ERROR: String does not end.", srow, scol);
				TERMINATE;
			case '\'':
			case '\\':
			case '\"':
			case '\?':
				ESC_CHAR((char)c);
			default:
				yymsg("ERROR: Unknown escape character.", srow, scol);
				TERMINATE;
		}
	}
	[^\"\n\\]*\"		{
		ADVANCE;
		yytext[yyleng - 1] = 0; /* Remove the '"'. */
		qstr << yytext;
		BEGIN( INITIAL );
		yylloc.first_line = srow;
		yylloc.first_column = scol;
		yylloc.last_line = yyrow;
		yylloc.last_column = yycol;
		yylval = new ASTString(qstr.str(), yylloc);
		return TOK_QUOTEDSTRING;
	}
}
 /* Import String */
 <IMPORTING>{
	<<EOF>>			{
		yymsg("ERROR: Import without string", srow, scol);
		TERMINATE;
	}
	[^\"\n]*\n]		{ //newline, without open quotation
		yymsg("ERROR: Import without string", srow, scol);
		TERMINATE;
	}
	\" {
		BEGIN( IMPORTSTR );
		qstr.str(""); /* Clear qstr */
		srow = yyrow;
		scol = yycol;
		ADVANCE;
	}
 }
 
 <IMPORTSTR>{
	<<EOF>>			{
		yymsg("ERROR: String does not end.", srow, scol);
		TERMINATE;
	}
	[^\"\n]*		ADVANCE; qstr << yytext;
	[^\"\n]*\n		NEWLINE; qstr << yytext;
	[^\"\n]*\"		{
		ADVANCE;
		yytext[yyleng - 1] = 0; /* Remove the '"'. */
		qstr << yytext;
		BEGIN( INITIAL );
		yylloc.first_line = srow;
		yylloc.first_column = scol;
		yylloc.last_line = yyrow;
		yylloc.last_column = yycol;
		yylval = new ASTString(qstr.str(), yylloc);
		return TOK_IMPORTSTRING;
	}
 }

 /* Identifier */
[_a-zA-Z][_a-zA-Z0-9]*	{
	VALUE( IDENTIFIER, ASTString(yytext, yylloc) );
}

 /* Numbers */
[0-9]*\.?[0-9]+ 	{
	VALUE( NUMBER, ASTFloat(yytext, ASTFloat::TYPE_DECIMAL, yylloc) );
}
0x[0-9a-fA-F]+ 		{
	VALUE( NUMBER, ASTFloat(yytext, ASTFloat::TYPE_HEX, yylloc) );
}
[0-1]+b			{
	VALUE( NUMBER, ASTFloat(yytext, ASTFloat::TYPE_BINARY, yylloc) );
}

 /* Char */
\'[^\']?\' {
	VALUE( SINGLECHAR, ASTString(yytext, yylloc) );
}

\'\\[^\n]\'	{
	switch(yytext[yyleng-2])
	{
		case 'a':
			yytext[yyleng-3] = '\a';
			break;
		case 'b':
			yytext[yyleng-3] = '\b';
			break;
		case 'f':
			yytext[yyleng-3] = '\f';
			break;
		case 'n':
			yytext[yyleng-3] = '\n';
			break;
		case 'r':
			yytext[yyleng-3] = '\r';
			break;
		case 't':
			yytext[yyleng-3] = '\t';
			break;
		case 'v':
			yytext[yyleng-3] = '\v';
			break;
		case '\'':
		case '\\':
		case '\"':
		case '\?':
			yytext[yyleng-3] = yytext[yyleng-2];
			break;
		default:
			yymsg("ERROR: Unknown escape character.", srow, scol);
			TERMINATE;
	}
	yytext[yyleng-2] = yytext[yyleng-1];
	yytext[yyleng-1] = 0;
	VALUE( SINGLECHAR, ASTString(yytext, yylloc) );
}

\'\\x[0-9a-fA-F][0-9a-fA-F]?\' {
	int x = yytext[yyleng-3]=='x' ? yyleng-3 : yyleng-4;
	std::stringstream escstr;
	escstr.str("");
	escstr << yytext[x+1];
	if(yytext[x+2]!='\'')
		escstr << yytext[x+2];
	std::stringstream buf;
	int temp;
	buf << std::hex << escstr.str();
	buf >> temp;
	yytext[x-1] = (char)temp;
	yytext[x] = '\'';
	//Clear the extra space
	for(int q = x+1; q < yyleng; ++q)
		yytext[q] = 0;
	VALUE( SINGLECHAR, ASTString(yytext, yylloc) );
}

 /* Whitespace */
[ \t\r]*\n	NEWLINE;
[ \t\r]+	ADVANCE;

 /* Error */
.		yymsg("WARNING: Unknown Character");

%%

void resetLexer() {
	YY_FLUSH_BUFFER;
	yyrow = 1;
	yycol = 1;
}
