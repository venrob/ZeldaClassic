		
/////////////////
///  ZScript  ///
/////////////////

The following documents the changes, and expansions to the ZScript language in ZQuest/ZC 
	versions 2.54, and 2.55. 
	
Document for: 2.55, Alpha 24
Document Revision: 3rd June, 2019


////////////////////////////////////////////////////
/// ZSCRIPT PARSER AND LEXER ///////////////////////
////////////////////////////////////////////////////

////////////
// Tokens //
////////////

The ZScript parser now supports the following standard tokens:

and 	: 	Equivalent to 	&&
or 	: 	Equivalent to 	||
not 	: 	Equivalent to 	!
bitand 	: 	Equivalent to 	&
bitor 	: 	Equivalent to 	|
not_eq 	:	Equivalent to 	!=
or_eq 	: 	Equivalent to 	|=
xor_eq 	: 	Equivalent to 	^=
and_eq 	: 	Equivalent to 	&=
xor 	: 	Equivalent to 	^
compl	: 	Equivalent to	~

//////////////
// Bugfixes //
//////////////

	//Aplha 24
	
	///////////////
	// NOT Token //
	///////////////
	
	You may now use the NOt (!) token on any datatype, as in C++.
	Example:
		ffc f;
		if ( !f ) f = Screen->LoadFFC(3)l
		
		bitmap b;
		if ( !b ) b = Game->CreateBitmap(16,16);
		else b->Create(0, 16, 16);
		
	This allows checking if a pointer is initialised, easily. 

	//Alpha 16
	
	///////////////////
	// Short Circuit //
	///////////////////
	
	Fixed short-circuiting. Logical AND and Logical OR now short-circuit as in C,
	based on a compiler flag.
	
	If short-circuiting is enabled, the following occurs:
	
		if ( a && b ) 
			//if 'a' is false, 'b' is skipped.
		if ( a || b )
			//if 'a' is true, 'b' is skipped. 
	
	//Alpha 13
	
	///////////////////////
	// Constant Division //
	///////////////////////
	
	Fixed a bug where division of a constant would result in truncation that did not occur in 2.50.x
	Fixed issues with division by an integer, where values would be truncated.
	Added #option TRUNCATE_DIVISION_BY_LITERAL_BUG as a compiler flag to enable the old, 2.50.x behaviour
	Fixed scope resolution for identifiers and variables when used across
		imported files.
		Example:

			//buffer

			import "bar.zs"
			void foo()
			{
				scrid.bar();
			}
			////////////////////end of buffer
			
			//bar.zs
			
			ffc script scrid
			{
				void run(){}
				voud bar(){ Trace(1); }
			}
		
		This worked in 2.50.x, but broke at some point in 2.55, and the
		correct behaviour has been restored. 
			
		Scoped identifiers must be read-in, in linear order. Thus, this
		would not be valid:
			
			//buffer

			
			void foo()
			{
				scrid.bar();
			}
			
			import "bar.zs"
			////////////////////end of buffer
			
			//bar.zs
			
			ffc script scrid
			{
				void run(){}
				voud bar(){ Trace(1); }
			}
			
		The import directive containing the token that you are resolving must be declared first,
		or be processed first, before it can be used. 
			
	Script errors will now give line and column references prior to the
		error type.
			
		Old:
			Error S007: Variable X can't have type VOID.
				@ LINE 4 COLUMNS 1-11
			
		New: 
			LINE 4 @ COLUMNS 1-11 - ERROR S007: Variable X can't have type VOID.
			
	Fixed some issues where compiler errors improperly carried over. 

	Fixed import directive pathing with backslashes:
		Importing in zscript with a path such as scripts\scriptfile.z used to work, in prior versions. 
		As of 2.55, it reads \ as an escape character, and parses the file path improperly. 
		This has now been corrected, so that you may use / or \ as a valid path token, however, / is the better option.
			

//////////////////
// Script Types //
//////////////////

//////////////
// Waitdraw //
//////////////

The following script types npw support Waitdraw():
ffc, screendata, eweapon, itemsprite, item.
You may disable Waitdraw support (for compatibility reasons) for ffc scripts, 
	and item scripts in the ZScript Quest Settings Dialogue.
	
Waitdraw support for npc, and lweapon scripts remains t/b/a.

///////////////////
/// NPC Scripts ///
///////////////////

TOKEN: npc script

* You can now compile and assign scripts to npcs. 
* The 'this' pointer for npc scripts is npc (ri->guyref).
* You can assign this script type to enemies in the ENEMY EDITOR:
* 	To do this, select the 'Scripts' tab, and then select the 'Action Script' tab. 
* You may assign scripts to enemies from other scripts, via npc->Script.
*
* You can read, or write to the ENEMY EDITOR data for the script ID, with npcdata->Script
* 	on an initialised npc pointer.
*
* Enemies have eight InitD[] args, in the ENEMY EDITOR for this script type.
* 	You may assign values to these in the ENEMY EDITOR, and you may label the fields
* 	for these InitD values in the ENEMY EDITOR.
* 	You may also read or write to them by script with npc->InitD[] (or this->InitD[])
* 	or npcdata->InitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.
* Use of these on Room Guys is untested, but should be feasible. 


///////////////////////
/// EWeapon Scripts ///
///////////////////////

TOKEN: eweapon script

* You can now compile and assign scripts to eweapons.
* The 'this' pointer for npc scripts is eweapon (ri->ewpn).
* You can assign this script type to the weapon generated by an npc in the ENEMY EDITOR.
* 	To do this, select the 'Scripts' tab, and then select the 'Weapon Script' tab. 
* You may assign scripts to eweapons from other scripts, via eweapon->Script, 
* 	on an initialised eweapon pointer.
*
* You can read, or write to the ENEMY EDITOR data for the script ID, with npcdata->WeaponScript.
*
* Enemy Weapons have eight InitD[] args, in the ENEMY EDITOR for this script type.
* 	You may assign values to these in the ENEMY EDITOR, and you may label the fields
* 	for these InitD values in the ENEMY EDITOR.
* 	You may also read or write to them by script with eweapon->InitD[] (or this->InitD[])
* 	or npcdata->WeaponInitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.

///////////////////////
/// LWeapon Scripts ///
///////////////////////

TOKEN: lweapon script

* You can now compile and assign scripts to lweapons.
* The 'this' pointer for npc scripts is lweapon (ri->lwpn).
* You can assign this script type to the weapon generated by an item in the ITEM EDITOR.
* 	To do this, select the 'Scripts' tab, and then select the 'Weapon Script' tab (W.Script).
* You may assign scripts to lweapons from other scripts, via eweapon->Script
* 	on an initialised lweapon pointer.
*
* You can read, or write to the ITEM EDITOR data for the script ID, with itemdata->WeaponScript.
*
* Link Weapons have eight InitD[] args, in the ITEM EDITOR for this script type.
* 	You may assign values to these in the ITEM EDITOR, and you may label the fields
* 	for these InitD values in the ITEM EDITOR.
* 	You may also read or write to them by script with lweapon->InitD[] (or this->InitD[])
* 	or itemdata->WeaponInitD[]. 
* Trying to modify the script while it is running with this->Script, is untested.


////////////////////
/// Hero Scripts ///
////////////////////

TOKEN: hero script, player script; link script (deprecated)

* You can now compile and assign scripts to the Hero.
* The 'this' pointer is identical to `Hero`, ex. `this->X` `this->Y` `this->HP`
* When you compile this script type, you can assign it to one of the following slots,
* 	which determines when it runs, and how often it runs:
*
* 	HERO INIT
* 	This script runs FOR ONE FRAME at the start of every game session (not on F6 Continue), 
*		and it allows you to set up initial values for Link, BEFORE the opening wipe,
*		such as his Invisibility state, or his screen position.
* 		You can give him equipment, and other effects at this time.
*		These effects take place BEFORE the engine writes to Screen->EntryX,
*			and Screen->EntryY, so if you give Link custom starting coordinates
*			by script, reading those values from the Screen pointer, should 
* 			give you accurate data.
*
*	HERO ACTIVE
*	This script runs after HERO INIT, and also after the GLOBAL ACTIVE script.
*	The HERO ACTIVE script can run for multiple frames, until either it runs out of
*		scope, or you call Quit() inside the script body.
* 	You may use Waitdraw() in this script type. 
*	
*	If Hero dies, this script halts.
*	If Hero wins the game, this script halts.
*
*	HERO DEATH
*	This script runs when Hero DIES. 
*	It runs AFTER the GLOBAL EXIT script, and after Hero is DEAD, with no chance of revival.
*		^ If you need to revive Link, such as with a Faerie in a Bottle, use his Active
*		^ script for this effect. 
*
*	This script can run for multiple frames, and is intended to permit you to construct your
*		own Game Over sequences.
*
*	HERO WIN
*	This script runs if Link WINS THE GAME (Flag 15).
*	It can run for more than one frame, and it is intended to permit you to make your own
*		Game Ending scenes, or credits scroll.
*	You can disable the internal credits scroll, or you can permit that to run normally,
*		with Game->SkipCredits.
*
*	These scripts automatically run when their conditions are valid, based on the
*	script slot, to which you assign them.


////////////////////
/// DMap Scripts ///
////////////////////

TOKEN: dmapdata script

* You can now compile and assign scripts to DMaps.
* The 'this' pointer for dmapdata scripts is dmapdata (ri->dmapsref).
*
* This script can run for multiple frames, and it runs after the GLOBAL ACTIVE script.
* You may use Waitdraw() in this script type. 
*
* DMap scripts run only on DMaps where they are set to run.
* Warping to a DMap with a dmap script will start that script.
*
* You can assign this script to a DMap in the DMAPS EDITOR dialogue. 
*	To do this, open the DMAPS EDITOR, and select the 'Scripts' tab.
*
* You may assign scripts to DMaps from other scripts, via dmapdata->Script
* 	on an initialised dmapdata pointer.
*
* DMap Scripts have eight InitD[] args, in the DMAP EDITOR for this script type.
* 	You may assign values to these in the DMAP EDITOR, and you may label the fields
* 	for these InitD values in the DMAP EDITOR.
* 	You may also read or write to them by script with dmapdata->InitD[] (or this->InitD[])
* 	or itemdata->WeaponInitD[]. 
*
* Trying to modify the script while it is running with this->Script, is untested.


//////////////////////
/// Screen Scripts ///
//////////////////////

TOKEN: screendata script

* You can now compile and assign scripts to individual screens.
* The 'this' pointer for dmapdata scripts is Screen->.
*
* This script can run for multiple frames, and it runs before ffcs.
* You can enable the tick box 'Run on Screen Init'. if this is enabled, ther script runs as soon as the screen
* starts to scroll into view.
*
* Screen scripts run only on screens where they are set to run.
* Warping to a screen with a screen script will start that script.
*
* You can assign this script to a screen in the SCREEN SCRIPT EDITOR dialogue. 
*	To do this, access the Screen menu, and select the entry 'Script'.
*
* You may assign scripts to screens from other scripts, via Screen->Script, or mapdata->Script
* 	on an initialised mapdata pointer.
*
* Screen Scripts have eight InitD[] args, in the SCREEN SCRIPT EDITOR for this script type.
* 	You may assign values to these in the SCREEN SCRIPT EDITOR, but you may not label the fields
* 	for these InitD values in the SCREEN SCRIPT EDITOR.
* 	You may also read or write to them by script with Screen->InitD[] (or mapdata->InitD[], or this->InitD[]).
*
* Trying to modify the script while it is running with this->Script, is untested.


//////////////////////////
/// itemsprite Scripts ///
//////////////////////////

TOKEN: itemsprite script

* You can now compile and assign scripts to items that appear on the screen.
* The 'this' pointer for itemsprite scripts is item (ri->itemsref).
*
* This script can run for multiple frames. It automatically ends if the item becomes invalid.
*
* You can assign this script to an item in the ITEM EDITOR dialogue. 
*	To do this, open the ITEM EDITOR, and select the 'Scripts' tab.
*       Use the SPRITE SCRIPT lister to set this script type. 
*
* itemsprite Scripts have eight InitD[] args, in the ITEM EDITOR for this script type.
* 	You may assign values to these in the ITEM EDITOR, and you may label the fields
* 	for these InitD values in the ITEM EDITOR.
* 	You may also read or write to them by script with item>InitD[] (or this->InitD[])
*
* Trying to modify the script while it is running with this->Script, is untested.


///////////////////////////
/// Item Script Changes ///
///////////////////////////

It is now possible to permit item scripts to run for more than one frame.
	To do this, you must enable the Quest Rule, 'Item Scripts Continue to Run', 
	in Quest->Rules->Scripts.
	
	This rule is disabled by default, and disabled for all legacy quests, for compatibility
	reasons.


///////////////////////////
/// Compiler Directives ///
///////////////////////////

	There's a new compile_error directive that ignores the next compiler error/warning of the 
	specified number, that you can use to suppress warnings or halts. 

	Syntax:
	#ignore error(error_number) {error_generating_code}
	#ignore warning(error_number) {error_generating_code}
	catch(error_number) {error_generating_code}
	

//////////////////////
// import, #include //
//////////////////////

The import directive now checks include paths. 
Order and Priority: It first checks an absolute path, then relative to the ZQ binaries,
	then include paths. 
	
The new directive, #include, checks include paths first, then root, then absolute. 
	

///////////////////
// Header Guards //
///////////////////

The default behaviour for importing duplicate headers / files is now to issue a warning, and ignore the
duplicate import directive. 

You can toggle this behaviour as follows:
	#option HEADER_GUARD warn
		Enables protection, and issues warnings on duplication.
		This is the default.
	#option HEADER_GUARD on
		Enables protection, but issues no warnings.
	#option HEADER_GUARD error
		Halts on finding a duplication.
	#option HEADER_GUARD off
		Halts, and does not give data, as 2.50.
		
If this option is set to anything other than 'off', then the compiler will detail the location of the
original import, and the location of the duplicate, per instance of duplication. 
	

///////////////////////////
// Compiler Option Flags //
///////////////////////////

There are now compiler flags that you may enable, or disable, to
emulate old bugs, or to toggle certain actions.

To use these, call the #option directive, followed by the flag macro, and (on | off | inherit).
	#option LOGGING off
	
	Flag types:
		on : This enables the option.
		off: This disables the option.
		inherit: This causes the option to inherit from its last state (e.g., from an imported file). 
		default: Use the default ZQuest value for this option. (t/b/a, as a config file setting).
	
	MACROS
	
	TRUNCATE_DIVISION_BY_LITERAL_BUG
		Off by default.
		Enable this to force scripts to comply to the 2.50.x
			bug, where division by a literal resulted in truncation.
	
	LOGGING
		On by default.
		If set 'off', then all calls to trace() functions will be ignored. 
		
	//This list needs to be updated -V
		
Files default to inheriting the option state of the file that imported them. For the buffer, this will use the defaults.
You may force an option to its' default value by setting it to 'default'
The default values can be modified in ZQuest, under 'ZScript->Compiler Settings'.

Note: 	You can use any constant expression, or constant value that is one to represent 'on',
	and any constant expression, or constant value that is zero to represent 'off'.
	For options which only take 'on' or 'off', any other value is treated as 'on'.
	You can use any constant expression, or constant value that is two to represent 'error',
	and any constant expression, or constant value that is three to represent 'warn'.
	The options 'inherit', and 'default' are specific, and not bound to any literal value. 
	Thus, you cannot create macros for them, or otherwise trigger them with constant expressions.
	

///////////////////////////////////////
// Single Character Escape Sequences //
///////////////////////////////////////

You may now use escape sequences in a SINGLECHAR type:
	int tab = '\t';
	
	Valid Escape Characters
	\a     		Alert (Beep, Bell) (added in C89)[1]
	\b    		Backspace
	\f     		Formfeed Page Break
	\n     		Newline (Line Feed); see notes below
	\r     		Carriage Return
	\t     		Horizontal Tab
	\v     		Vertical Tab
	\\     		Backslash
	\'     		Single quotation mark
	\"     		Double quotation mark
	\?     		Question mark (used to avoid trigraphs) 
	\x0 to \xFF   	Normal ANSI characters, as hex value. 
	

/////////////////////////
// Ternary Expressions //
/////////////////////////

You may now use C-style ternary expressions:

	int x = Rand(6,8);
	int y = x > 7 ? 1 : 0;
	
	Assigns, and operations inside ternary blocks must be in parens:
		bool V = true;
		int b;
		int a = V ? ( b =  5 ) ? ( b = 4 );
		
		int c = V ? ( b -= 2 ) ? 0; 
		
		int y; int z; 
		int x = (y += 10) ? (z = 5) : (a -= 2);
		
	In all of these cases, parens are mandatory. 
	
	Further, compound ternary expressions should be placed in parens:
		int a = (V ? 1 : 0) ? 5 : 6
		
	The default, is to evaluate in a linear sequence.
			
	Thus, 
		bool ? int : int ? bool : int
	...would evaluate as: 
		bool ? int : (int ? bool : int)
	
	Using parens to define your order of operations and scope, is prudent. 

///////////////////////////
// Variable Declarations //
///////////////////////////

You can now declare, and initialise variables on one line, as in C.
	Format:
	TYPE (identifier | identifier ASSIGN NUMBER) comma [repeating] SEMICOLON
	Examples:
		int a, b, c = 9, h = 16, f = c+h;
		float n = 1.04, m = 6.03;
		
		These are equivalent to:
		int a; int b; int c = 9; int h = 16; int f = c+h;
		float n = 1.04; float m = 6.03;

///////////////////
// Explicit Cast //
///////////////////

You may now explicitly cast a value, using a type in angle braces.

	ffc f = Screen->LoadFFC(15);
	int x = <int>f;

	f = <ffc>2;

//////////////////////
// Enumerated Lists //
//////////////////////

You can now define enumerated lists of constant values using the
standard C-style syntax of:

	enum { A, B, C, D = 10, E, F, G = 100, H };

	In this declaration, A == 0, B == 1, C == 2, D == 10, 
		E == 11, F == 12, G == 100, and H == 101.
		
		
You can also define a C style enumerated list with an identifier. 
This act defines a pseudo-datatype, with assignable values limited to
the values in the enumerated list.

	enum actiontype { none, walk, attack };
	
	Now, you can declare 'action' as a datatype.
	
	actiontype act;
	
	If you wish to assign a value to it, the value must be validated
	from the enumeration:
		act = walk; //Legal
		act = 7; //Error
		
	You can explicit cast values to these types to circumnavigate the
	restrictions.
		act = <actiontype>7; //this is legal. 

////////////////////
// Comment Blocks //
////////////////////

	The ZScript language now supports C-Style comment blocks using the traditional syntax of:

	[example--

		/* 
			COMMENT BLOCK
			
		*/
		
	--end example]
	
///////////////
// Namespace //
///////////////

ZScript now supports C-style namespaces.

Declaration examples:

namespace foo
{
	int x(){return 16;}
}

namespace bar
{
	int y(){return 32;}
	namespace foobar
	{
		int z(){ return 64;}
	}
}

namespace doh
{
	int xyz(){return 128;}
}

Access examples:

foo::x();
bar::y();
bar::foobar::z();

/////////////////////
// Using Namespace //
/////////////////////

You may invoke the 'using' token to bring the contents of a namespaces
into the current scope, thus ignoring the requirement for scope-resolution
(::) until the end of that scope.

You may also invoke 'using' as 'always using' to make that namespace global; this cannot be undone.

The following scopes are valid:

file
script
function


Using the above namespaces as examples:

	//buffer
	always using namespace doh;
	//now in scope in all files, functions, and scripts
	//never falls out of scope
	//cannot be undone

	///file 1
	using namespace foo;

	//we can now ignore scope resolution for namespace foo
	x(); //now equivalent to foo::x();
	//end of file; namespace falls out of scope.

	//file 2
	using namespace bar::foobar;
	z(); //now equivalent to bar:foobar::z();
	//end of file; namespace falls out of scope.

	//function
	void main()
	{
		using namespace bar;
		y();
	} //namespace falls out of scope

	ffc script f
	{
		using namespace foo; //whole script
		void run()
		{
			using namespace bar; //only in run()
			int v = x();
			int w = y();
		}
		void n()
		{
			int r = y(); //illegal
		}
	}

////////////////////////////////////
// Array Declaration Improvements //
////////////////////////////////////

	Arrays now support being declared with any constant expression.:

	[example--

		int arr[10*4]; 
		//This is now the same as int arr[40];
		
	--end example]

	Nesting array calls should now work properly. (e.g. arrA[ arrB[ arrC[ arrD[4] ] ] ] )

	Further, you may now use constants in array declarations:

	[example--

		const int sARR_MAX = 20;
		int arr[sARR_MAX];
		
	--end example]

/////////////////////
// String Literals //
/////////////////////

	You may now use C-style string literals at any non-global scope.

	[example--

		TraceS("Trace this string.");
		
	--end example]


	You may use standard C-style escape characters in string literals:

	- \a\b\f\n\r\t\v for the standard values,
	- \" for quotes
	- You can escape a newline to make it not appear in the string

	Additionally, adjacent strings are merged by the compiler.

	
/////////////////////
// Global Pointers //
/////////////////////

	You may now declare any datatype, including arrays for any datatype at a global scope.
	*	Data saved to these may become invalid and require manual cleansing by the user!
	*	Only the value of a pointer is saved, not the struct data associated with that pointer.

////////////
// Unless //
////////////

This statement runs the code block attached to it if its statement would evaluate false
in an if statement.

Example: 
	int x = 6; int y;
	unless(x==6)
	{
		y = 1;
	}
	
	In this example, the code block would never run, because x == 6. 
	This is the opposite of 'if', and supports 'else unless' and 'else'
	blocks following the unless statement.
	
////////////
// Repeat //
////////////

Repeats a command a given number of times.
The value passed to repeat(const int v) bust be constant at compile time.

Example:
	const int N = 10;
	int x;
	repeat(N { ++x; }
	
This is similar to a for loop, but it produces faster ZASM, because the number
of iterations is known at compile-time.

/////////////////////
// Until, do-until //
/////////////////////

	ZScript now supports the Pascal-style token 'until'. 
	This functions as an inverted 'while' statement.
	Aside from the obvious semantical enhancement over 'while(!expression)', the advantage of 
	this, is that 'until(expression)' is faster (in ASM instructions) than 'while(!expression)'.
	
	Examples:
	
		until(x > 7) { DoSomething(); }
		
		do
		{
			Something();
		} until ( x > 7 );


/////////////////
// Switch-Case //
/////////////////

	ZScript now supports C-style switch statements. Case values must be numeric literals,
	or constant expressions. Switch-case cases must end in a break instruction, and a you
	may provide a default case.

	[example-- 

		const int SOME_CONST = 11;

		switch(var)
		{
			case 1:
			{
				DoSomething(); 
				break
			}
			case SOME_CONST:
			{
				DoSomethingElse();
				break:
			}
			case SOME_CONST+(10*2)
			{
				DoOther();
				break;
			}
			default:
			{
				DoDefault();
				break;
			}
		}

	--end example]

/////////////
// Typedef //
/////////////

	You can now define your own types using typedef using normal C syntax:

	typedef old_type new_type;

	[example--
		typedef object ffc; //Allows you to declare object vars that are typed to ffc. 

		typedef const int DEFINE;
		//Allows you to use the token DEFINE to declare constant ints. 
		
	--end example]


///////////////////////////////
/// Expanded Array Literals ///
///////////////////////////////

	Array Literals of the following form may be used in lots of places,
	not just array variable declarations.

	{0, 1, 2}
	(int[]){0, 1, 2}
	(int[3]){}
	(int[3]){4}

	[example--
	
		RunFFCScript(script_no, (int[8]){arg1, arg2, arg3});
		
	--end example]

//////////////////////////////////
/// Mechanical and AST Changes ///
//////////////////////////////////

	Assignment is now an expression instead of a statement. You can theoretically assign 
	inside of a statement now.
	
	[example--
		
		ffc script foo
		{
			void run()
			{
				int x = 0;
				while( (x+=2) < 20 ) Waitframe();
			}
		}
		
	--end example]

	Constants are now treated as normal (unassignable) variables up through type checking. 
	If at that point the constant's value is known, it is stripped out of the AST and its 
	value is saved to the symbol table, similar to how it worked before.

	If the constant's value is not known at compile time, it is instead treated as a normal, 
	unassignable variable by the parser. (It still uses no stack space.)

	Constants can now be declared in any scope, not just global scope, and the constant is only
	valid within its scope, so you may now have constants on a per-script, or per-scope basis. 
	
	[example--
	
		ffc script foo
		{
			void run()
			{
				const int X = 10;
				int a = X;
			}
		}
	
	--end example]
	
	You may assign a value to a constant using any constant expression.
	
	[example--
	
		const int A = 5;
		const int B = 10;
		const int C = A*(Pow(B,2));
	
	--end example]



///////////////////
// New Datatypes //
///////////////////

	untyped : A special datatype that can be cast to and from any other type.
	This has no distinct type of its own.
	
	Example:
		untyped ptrs[4];
		ffc f = Screen->LoadFFC(2);
		npc n = Screen->CreateNPC(16);
		lweapon l = Screen->CreateLWeapon(LW_SCRIPT);
		bitmap bitty = Game->CreateBitmap(160,240);
		
		ptrs[0] = f;
		ptrs[1] = n;
		ptrs[2] = l;
		ptrs[3] = bitty;
		
		//These now contain the raw literal value of the pointers to those objects.
		
		bool a = true;
		untyped b = a; //b == 0.0001
		int c = b; //c == 0.0001 

	npcdata: 

	combodata:

	spritedata:

	mapdata: 

	dmapdata : 

	messagedata :

	shopdata :


	dropdata : t/b/a
	bitmap : t/b/a
	warpring : t/b/a
	doorset : t/b/a
	misccolors : t/b/a
	rgbdata : t/b/a
	palette : t/b/a
	zcmidi : t/b/a
	palcycle : t/b/a
	gamedata : t/b/a
	cheats : t/b/a


//////////////////
// New Pointers //
//////////////////

	Hero->
	Player->
	
		These are synonymous with the old Link-> pointer, which is now deprecated but retained
		for compatibility purposes. 
	
	Graphics->

	Audio->

	Input->

	Text->



////////////////////////////////////////////////////
/// NEW ZSCRIPT INSTRUCTIONS ///////////////////////
////////////////////////////////////////////////////

//////////////
//  Global  //
//////////////

int utol(*string);
 * Converts all uppercase characters in a string to lowercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.
 
int ltou(*string);
 * Converts all lowercase characters in a string to uppercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.
 
int convcase(*string);
 * Converts all lowercase characters in a string to uppercase characters, and
 * all uppercase characters in a string to lowercase characters.
 * Returns the pointer to the string.
 * String MUST not be a literal.

int ilen(string[]);
 * Returns the number of characters used by a number in the string.
 * Includes the sign, if negative. 

int itoa(int value, dest_string[]);
 * Places value into a string as char. 
 * Returns the number of characters used in the conversion. 

int strcmp(string_a[], string_b[]);
 * Iterates through string_a and string_b until a character is found which is not the same in
 * both strings, and then returns > 0 if the character is larger in str1, and < 0 if it is
 * larger in str2. Returns 0 if the strings are equal.
 * The old string.zh version of this function is still available as:
 * std::string::strcmp(*a, *b).
 
int strncmp(string_a[], string_b[], int num_chars);
 * As strcmp(*a, *b), but compares only the first nth characters, specified as num_chars.
 * The old string.zh version of this function is still available as:
 * std::string::strncmp(*a, *b, int).

int strlen(string[]);
 * Returns the length of a string in characters.
 * The old string.zh version of this function is still available as:
 * std::string::strlen(*a).

void strcpy(string_dest[], string_src[]);
 * Copies string string_src into string_dest.
 * The old string.zh version of this function is still available as:
 * std::string::strcpy(*a,*b).
 
int atoi(string[]);
 * Returns the decimal value of a string consisting of a number.
 * e.g. ("26" would return 26).
 
int strcat(atring_a[], string_b[]);
 * Append the contents of string_b onto string_a.
 * Returns the pointer to string_a.
 
int strchr(string[], int chr);
 * Returns the first index in string that matches 'chr'.

int strrchr(string[], int chr);
 * Reverse of strchr, finding the last instance of a character in a string.
 
int strspn(string[], string_keys[]);
 * Returns the number of characters in a string before a character not contained in
 * 'string_keys' is found
 
int strcspn(string[], string_keys[]);
 * Returns the length of characters in a string before a character contained in
 * 'string_keys' is found
 
int GetSystemTime(int index);
 * Returns the time (Real Time Clock) data from the system on which ZC is running.
 * You may read the following indices: Year, month, day of the month (n/month), day of the week (n/7), 
 * 	hour, minute, second, and day of the year (n/365). 
 * Use the RTC_* constants in std_constants.zh for the index type that you wish to read.

void OverlayTile(int firsttile, int secondtile);		
* Overlay one tile onto another.

int SizeOfArray(bool array[]);
 * SizeOfArray() now returns the size of all datatypes.

void Trace(untyped)
 * The Trace() instruction now supports all datatypes.

untyped Untype(any)
 * Converts the value of any datatype to another, similar to typecasting.
 * Example:
  int x; 
  npc n = Screen->LoadNPC(10);
  x = Untype(n);

/************************************************************************************************************/

////////////
//  Game  //
////////////

Adds ZScript:

Game->GetNPCScript("name");
 * Returns the slot ID of the npc script 'name'.
 * Returns -1 if there is no match.
 
Game->GetLWeaponScript("name");
 * Returns the slot ID of the lweapon script 'name'.
 * Returns -1 if there is no match.
 
Game->GetEWeaponScript("name");
 * Returns the slot ID of the eweapon script 'name'.
 * Returns -1 if there is no match.
 
Game->GetHeroScript("name");
Game->GetLinkScript("name");
Game->GetPlayerScript("name");
 * Returns the slot ID of the hero script 'name'.
 * Returns -1 if there is no match.

Game->GetDMapScript("name");
 * Returns the slot ID of the dmapdata script 'name'.
 * Returns -1 if there is no match.
 
Game->GetScreenScript("name");
 * Returns the slot ID of the screendata script 'name'.
 * Returns -1 if there is no match.
 
Game->GetSubscreenScript("name");
 * Returns the slot ID of the subscreen script 'name'.
 * Returns -1 if there is no match.
 * Thos script type is not implemented at this time.
 
Game->GetUntypedScript("name");
 * Returns 0; not implemented as this script type has no slot assignment at this time.
 
Game->GetItemSpriteScript("name");
 * Returns the slot ID of the itemsprite script 'name'.
 * Returns -1 if there is no match.
 
Game->GetNPC("name");
 * Returns the ID of the npc 'name'.
 * Returns -1 if there is no match.
 
Game->GetItem("name");
 * Returns the ID of the item 'name'.
 * Returns -1 if there is no match.
 
Game->GetDMap("name");
 * Returns the ID of the DMap 'name'.
 * Returns -1 if there is no match.
 
Game->GetCombo("name");
 * Returns the ID of the first combo with label 'name'.
 * Returns -1 if there is no match.
 
bool FFRules[800];
 * An array consisting of all quest rules. 

void Continue();
 * As Game->End(), but this continues the game as if the user had selected the
 * CONTINUE option on the game over screen.

void ShowContinueScreen();
 * As void ShowSaveScreen(), but it shows the base Save/Retry/Continue screen.

bool SkipF6;
 * Disables showing the Continue/Retry/Save menu if the player presses F6.
 * The prompt to exit the game is still shown.

bool SkipCredits;
 * If set true, the credits sequence shown at the end of the game is skipped.

bitmap CreateBitmap(int width, int height);
 * Creates a bitmap with a size of height, width, and returns its pointer.

bitmap LoadBitmapID(int id);
 * Loads one of the six internal bitmaps as a ref to a 'bitmap' typed pointer.

bitmap AcquireBitmap();
 * Initialises a bitmap pointer from the pool of unused bitmap IDs in the system.
 * The current maximum number of user bitmaps is 249. 
 * Returns 0 to the pointer on failure. 

int LItems[512];
 * The size of this array has been corrected to 512, from the prior size of 256.

LKeys[512];
 * The size of this array has been corrected to 512, from the prior size of 256.

combodata LoadComboData(int id);
 * Loads a Combo Editor table data ref for combo 'id', to a 'combodata' typed pointer.

npcdata LoadNPCData(int id);
 * Loads an Enemy Editor table data ref for NPC 'id', to a 'npcdata' typed pointer.

mapdata LoadMapData(int map, int screen);
 * Loads a screen data ref for screen ID 'screen', of Map ID 'map', to a 'mapdata' typed pointer.

spritedata LoadSpriteData(int id);
 * Loads an Weapon Sprite Editor table data ref for sprite 'id', to a 'spritedata' typed pointer.

messagedata LoadMessageData(int id);
 * Loads an String Table Editor table data ref for ZQ Message String 'id', to a 'messagedata' typed pointer.

shopdata LoadShopData(int shop);
 * Loads a Shop Editor table ref for an item shop with an ID of 'id' to a 'shopdata' typed pointer.
	
shopdata LoadInfoShopData(int shop);
 * Loads a Shop Editor table ref for an info shop with an ID of 'id' to a 'shopdata' typed pointer.
 * !! I may make 'infoshopdata' its own type, to prevent conflicts and reduce future shops expansion overhead. -Z

bool TypingMode;
 * If set true, all keyboard presses that would ordinarily perform an in-engine action are suppressed.
 * 	Example: The 'z' key is bound to the 'A Button'; the user presses the3 'z' key.
 *	if TypingMode == true, then that keystroke will not cause the engine to register a Button A Press.
 *
 *	Enable this if you wish to create a text prompt using Input->Key[] or Input->ReadKey[].
	
untyped Misc[32];
 * An array of 32 misc values that is always available.
 * Data does not persist between sessions.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].
 * !! Verify that Game->Misc[] is now untyped, to match all other Misc[] arrays. -Z
	
int HighestStringID;
 * Returns the highest valid ID of the strings in the ZQuest String Editor.

int NumMessages;
 * Returns the number of valid strings in the ZQuest String Editor.

int GameOverScreen[12];
 * INCOMPLETE
 * An array of 12 values that affect the visual, and auditory components of the internal
 *	'Game Over' screen, including fonts, colours, sound effects, and cursor tiles.

int GameOverStrings[3]; //
 * INCOMPLETE
 * An array of 3 values that contain the IDs of custom strings for the 'Game Over' screen.
	
int MapCount()				
 * Returns the number of maps used by a quest. 

void PauseSound(int soundid)	
 * Pauses one of the quest's playing sound effects. Use the SFX_ constants in

void ResumeSound(int soundid)
 * Resumes one of the quest's paused sound effects. Use the SFX_ constants in

void EndSound(int soundid)
 * Kills one of the quest's playing sound effects. Use the SFX_ constants in

void GreyscaleOn()
 * Renders the entire display in greyscale.

void GreyscaleOff() 
 * Returns the display rendering to colour. 

int DMapPalette[512]
 * Set or get the Level Palette for each DMap

void SetMessage(int message, int str[])
 * Places string 'str[]' into ZQ Message 'message'.

void SetMapName(int dmap, int str[])
 * Places string 'str[]' into DMap Name for DMap with ID 'dmap'

void SetMapTitle(int dmap, int str[])
 * Places string 'str[]' into DMap Title for DMap with ID 'dmap'

void SetMapIntro(int dmap, int str[])
 * Places string 'str[]' into DMap Intro for DMap with ID 'dmap'

//bool CappedFPS		
//* Check if the game is uncapped. 

int Version;				
 * Returns the version of ZC being used.  

int Build;			
 * Returns the Build ID of the version of ZC being used.  
			
int Beta;				
 * Returns the Beta ID of the version of ZC being used. If the build is not a beta, this returns 0. 
	
bool DisableActiveSubscreen;		
 * If set true, the active subscreen will not fall into view when the player presses Start.

int GetPointer(bool *ptr[]);
 * Returns the pointer of a bool array as a float. 

/* The following have been deprecated by other pointer types.

	int GetScreenEnemy(int map, int screen, int enemy_index)			
	* Reads values from enemy lists anywhere in the game. 

	int SetScreenEnemy(int map, int screen, int enemy_index, int enemy_id)			
	* Sets values to enemy lists anywhere in the game.

	int GetScreenDoor(int map, int screen, int index)			
	* Reads value of a door on any screen in the game environment.

	int SetScreenDoor(int map, int screen, int index, int type)			
	* Sets the value of a door on any screen in the game environment.

	void ContinueSound(int sfx); 					
									
	void AdjustSound(int sfx, int pan, bool loop);			
	* Adjusts properties of a sound effect. 

	void PauseMusic()	
	* Pauses the present, playing MIDI or Enhanced Music file. 

	void ResumeMusic()
	* Resumes the present, playing MIDI or Enhanced Music file. 

*/

/************************************************************************************************************/

////////////////
///  Screen  ///
////////////////

int Script; 
 * Returns the ID of the script set to the screen, or sets the script that this screen runs.
 
untyped InitD[8];
 * The eight script args for the script that runs on this screen.

lweapon CreateLWeaponDx(int type, int baseitem)
 * Create an lweapon with sprites, sounds, and other values set as if it was generated by a specific item.

TriggerSecret(int secret);
 * Triggers a specific secret type on the screen.
 * Might be using the SECCMB_* constants. -Z 30th April, 2019
 
void WavyIn();
 * Replicates the warping screen wave effect (inbound) from a tile warp. 

void WavyOut();		
 * Replicates the warping screen wave effect (outbound) from a tile warp. 

void ZapIn();			
 * Replicates the warping screen zap effect (inbound) from a tile warp. 

void ZapOut();		
 * Replicates the warping screen zap effect (outbound) from a tile warp. 

void OpeningWipe();	
 * Replicates the opening wipe screen effect (using the quest rule for its type) from a tile warp. 


void DrawBitmapEx	( int layer, 
			int bitmap_id, 
			int source_x, int source_y, int source_w, int source_h, 
			int dest_x, int dest_y, int dest_w, int dest_h, 
			float rotation, int cx, int cy, int mode, int lit,  bool mask);

 * As DrawBitmap(), except that it can do more things. 
 * Now supports multiple MODES, OR'd together as a bitmask:
 * const int BITDX_NORMAL = 0;
 * const int BITDX_TRANS = 0x01; //Translucent
 * const int BITDX_PIVOT = 0x02; //THe sprite will rotate at a specific point, instead of its centre.
 * const int BITDX_HFLIP = 0x04; //Horizontal Flip
 * const int BITDX_VFLIP = 0x08; //Vertical Flip.
 * You can also set a pivot point for the rotation, using 'int cx' and 'int cy'
 * If these are non-zero, the rotation anchor point will centre on these coordinates.
 * You may specify a colour to 'int lit' to use a lit mode. 


void FastCombo()
void DrawScreen()
void DrawLayer()
 * These now support Combo CSet values.

void PutPixels(int layer, int ptr[])
 * Puts multiple pixels to the screen in one function call.
 * PutPixels() expects an array as its arg, with the array in the format of
 * repeating blocks of { x, y, colour, trans }
 *	Example: PutPixels(1, { 25, 10, 5, OP_OPAQUE, 26, 10, 6, OP_OPAQUE } );
 *	This draws two pixels to the screen.
 *	The first is at coordinates x==25, y == 10, colour == 5, and it is opaque.
 *	The second is at coordinates x==25, y==10, colour == 6, and opaque.
	
void DrawTiles(int layer, int ptr[])
 * Similar to FastTile(), but it draws multiple tiles in one call.
 * The arg *ptr[] should be an array with repeating sets of:
 *	{x,y,tile,colour,opacity} 
 *	...per tile that you want to draw.

void DrawCombos(int layer, int ptr[]);
 * Similar to FastCombo, but draws multiple combos in one call.
 * The arg *ptr[] should be an array with repeating sets of: 
 *	{x,y,combo,cset,opacity} 
 *	...per combo that you want to draw.

void Lines(int layer, int ptr[]);
 * Similar to Line(0, but draws multiple lines in one call.
 * The arg *ptr[] should be an array with repeating sets of: 
 *	{ x, y, x2, y2, colour, scale, rx, ry, angle, opacity }
 *	...per line that you want to draw.
	
void Polygon(int layer, int num_points, int vertices[], int colour, int transparency);
	ZASM: POLYGON
 * Draws a polygon to the screen, with a number of points specified as int points,
 * with vertices supplied as an array. 

int Valid;
 * ?

int Guy;
 * The screen guy.

int String;
 * The screen string.

int RoomType;
 * The screen room type.

int Item;
 * The screen item.
 * Note: The NULL value is '0', which is a valid item.
 * 	To determine if there is an item on the screen, if you ever assigned
 * 	item 0 as a valid screen item in your quest, you will also want to read
 * 	HasItem for that screen.

int HasItem; 
 * If not zero, then the item for this screen will be shown.
 * When Link takes the item on a screen, this is set to 0.

int TileWarpType[4];
 * The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh TWTYPE_* constants for valid types.
	
int TileWarpOverlayFlags;
 * Combos carry over?

int DoorComboSet;
 * The doorset used by the screen, for NES dungeon doors.
	
int WarpReturnX[4];
 * The X-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnY[4];
 * The Y-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnC;
 * ?

int StairsX;
 * The X component for where a Stairs secret appears on the screen.
	
int StairsY;
 * The Y component for where a Stairs secret appears on the screen.
	
int ItemX;
 * The X component for the item location on the screen.
	
int ItemY;
 * The Y component for the item location on the screen.

int CSet;
 * ? The screen palette. ?

int TileWarpDMap[4];
 * The destination DMap for each of the four warp types.
	
int TileWarpScreen[4];
 * The destination screen for each of the four warp types.

int Enemy[10];
 * The IDs of the enemies that spawn on the screen.

int EnemyFlags;
 * A flagset for enemies on the screen (E.Flags).
 * Valid values (ORd) together, are:
 *
 *

int Pattern;
 * The enemy 'Spawn Pattern'.

int SideWarpType[4];
 * The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh SWTYPE_* constants for valid types.
	
int SideWarpOverlayFlags;
 * Carryover?

int SideWarpScreen[4];
 * The destination screen for each of the four sidewarps.
	
int SideWarpDMap[4];
 * The destination DMap for each of the four sidewarps.
	
int SideWarpIndex;
 * The warp return?? If so, should this be an array, or are these ORd values?

int WarpArrivalX;
 * The X-component for the pre-2.50 (green) arrival square.
	
int WarpArrivalY;
 * The X-component for the pre-2.50 (green) arrival square.
	
int MazePath[4];
 * The four Maze Path directions.

int ExitDir;
 * The Maze Path 'Exit Direction'.

int UnderCombo;
 * The undercombo ID used by the screen.

int UnderCSet;
 * The CSet of the undercombo used by the screen.

int Catchall;
 * The screen 'Catchall' value. 

int CSensitive;
 * The value of Damage Combo Sensitivity for the screen.
	
int NoReset;
 * The No Reset Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x
 * Door Up [0]		0x
 * Door Down[1]		0x
 * Door Left [2]	0x
 * Door Right [3]	0x

int NoCarry;
 * The No Carry Over Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x

int LayerMap[7];
 * The Map IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerScreen[7];
 * The Screen IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerOpacity[7];
 * The opacity value for each layer used by this screen.
 * Valid layers are 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int TimedWarpTimer;
 * The timer used by 'Time Warp Tics' in Screen Data->T.Warp

int NextMap;
 * ?

int NextScreen;
 *?

int SecretCombo[128];
 * The Combo IDs used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretCSet[128];
 * The CSets used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretFlags[128];
 * The Combo Flags used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int ViewX;
 * Unused at this time. Represents the visible width of the screen.

int ViewY;
 * Unused at this time. Represents the visible height of the screen.

int Width;
 * Unused at this time. Represents the physical;e width of the screen.

int Height;
 * Unused at this time. Represents the physical height of the screen.

int EntryX;
 * The X-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this X-component. 

int EntryY;
 * The Y-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this Y-component. 

int ScriptEntry;
 * ?

int ScriptOccupancy;
 * ?

int ExitScript;
 * ?

int OceanSFX;
 * The 'Ambient Sound' under S.Data2. 
 * Rename this to AmbientSFX, or just SFX.

int BossSFX;
 * The Boss Roar sound for this screen.
	
int SecretSFX;
 * The sound that will play on this screen, when secrets are triggered.

int ItemSFX;
 * The sound that will play if Link holds an item over his head on this screen.
	
int MIDI;
 * The MIDI that plays on this screen.

int LensLayer;
 * The layer to which Lens of Truth graphics are drawn.

int ScreenFlags[10];
 * A set of flagsets that contain special data for thiws screen.
 * These represent S.Flags1 and S.Flags2 flags.
 * See std_constants.zh (SFG* for the screen flag froup, 
 *	and SFX* for the screen flag value) for more information. 
	
int NumFFCs;
 * ? The number of ffcs running scripts?

//int Script; t/b/a

/************************************************************************************************************/

/////////////
///  FFC  ///
/////////////

int ID;	
 * The screen ref of the ffc. Used primarily for this->ID.

//bool Running; //need to add this to match mapdata. int val


/************************************************************************************************************/

//////////////
///  Item  ///
//////////////

int Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing.
 
int Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *  'Old (Faster) Sprite Drawing.

int Script;
 * The itemsprite script attached to this item.

int Family;
int Type;
 * The Family (Item Class) of the item.

untyped Misc[32];
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

int Pickup;
 * The pick-up type for this item.
	
int PickupString;
 * If this is > 0, then when Link touches the item, ZC will display a ZQ String Editor message string
 * equal to its value.
 * The precise behaviour of this is affected by PickupFlags.

int PickupStringFlags;
 * A flagset that determines the behaviour of string display.
 * Values are ORd together, as follows:
 *
 *
 *

int SizeFlags;
 * A flagset that determines how internal engine sizing of items is applied.
 * Values are ORd together, as follows:
 *
 *


float UID;	
 * Each item created by ZC in in a given session is assigned a unique ID (UID).
 * Returns the UID of an item.
 * UIDs begin at 00000.0001 and overflow at 214748.3748. 
 *	Note: This allows for 2,147,483,748 unique items, per-session.

int AClock 
 * The clock used for the item's animation cycle. 

/************************************************************************************************************/	

/////////////////
///  *weapon  ///
/////////////////

int Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing.
 
int Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing.
   
int Script;
 * The weapon script assigned to this weapon.

untyped InitD[8];
 * The eight InitD values for the weapon script used by this weapon.

int ScriptTile;
 * If set to 0 or higher, then the npc will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the npc.
 * The default value for this is -1. 

int Parent;
npc Parent;
 * The ID of the item, or pointer of the npc (respectively for lweapon, and for eweapon) that created this weapon.
 * Weapons created by script have a default Parent of -1 (lweapon) and <npc>-0.0001 (eweapon). 
	
int Level;
 * The Level value associated with the weapon. 

float UID;
 * Each weapon created by ZC in in a given session is assigned a unique ID (UID).
 * Returns the UID of a weapon.
 * UIDs begin at 00000.0001 and overflow at 214748.3748. 
 *	Note: This allows for 2,147,483,748 unique items, per-session.


untyped Misc[32];		
 * Epanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

///////////////////////////
///  LWeapon  Specific  ///
///////////////////////////

int Weapon;
 * The UseWeapon property for this weapon. 
 * If set to a value greater than 0, all collisions with npcs
 * will use this as if it was the weapon's ID for calculating
 * the defence value for it. 
 * e.g., if a LW_MAGIC weapon is set to a Weapon of LW_BRANG, when it
 * collides with an npc, the npc will use Defence[LW_BRANG] to resolve 
 * its effects.
 *
 * Some weapons will also trigger map flags, and screen combos as
 * if the natural weapon was the value set as ->Weapon.,
 * e.g. If you set a LW_BRANG weapon to a ->Weapon of LW_SWORD,
 * it will cut bushes. 

int Defence;
int Defense;
 * The default defence value for this weapon.
 * If set greater than 0, then when this weapon collides with an npc,
 * if that npc has its Defence[n] value set to NONE for this weapon's type,
 * it will resolve using this Defence value (e.g. Stun). 

int Range;
 * NEEDS TO BE REIMPLEMENTED
 * The range of boomerang and hookshot lweapons in pixels; and arrow lweapons in frames.

int AClock 
 * The clock used for the item's animation cycle. 

/************************************************************************************************************/		

/////////////
///  NPC  ///
/////////////

int Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
 *  'Old (Faster) Sprite Drawing.
 
int Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
 *   'Old (Faster) Sprite Drawing.

bool isDead();
 * Returns if the NPC is dead, or dying

bool CanSlide();
 * Checks if the npc can be knocked back
	
bool Slide(); 
 * Engine knockback

void Remove(); 
 * Instantly kills an npc

void StopBGSFX();
 * Stops the background sounds that the npc is generating.
	
void Attack();
 * Causes the npc to attack with its weapon.
	
void NewDir(int arr[]);
 * The npc chooses a new direction.
 * Uses an array literal for its args:
 * 	{ int rate, int homing, int special }

void NewDir8(int arr[]);
 * As NewDir(), but 8-directions.
 * 	{int rate, int homing, int special}
 *	{int rate, int homing, int special, int dx1, int dy1, int dx2, int dy2}

void ConstantWalk(int arr[]);
 * Causes the npc to walk.
 * Uses an array literal for its args.
 * Pass NULL as the pointer to run without args, or use:
 * 	{int rate, int homing, int special}

void ConstantWalk8(int arr[]);
 * As ConstantWalk(), but 8-directions.
 * 	{int rate, int homing, int special}

void VariableWalk(int arr[]);
 * Causes the npc to walk and occasionally change speed.
 * 	{int rate, int homing, int special}

void VariableWalk8(int arr[]);
 * As VariableWalk(), but 8-directions.
 * 	{int rate, int homing, int newclk, int special}
 * 	{int rate, int homing, int newclk, int special, int dx1, int dy1, int dx2, int dy2}

void HaltingWalk(int arr[]);
 * Causes an enemy to walk, and occasionally halt.
 * 	{int rate, int homing, int special, int hrate, int haltcnt}

void HaltingWalk8(int arr[]);
 * As HaltingWalk(), but 8-directions.
 * 	{int newrate, int newhoming, int newclk, int special, int newhrate, int haltcnt}
    
void FloatingWalk(int arr[]);
 * Causes an enemy to move, ignoring solidity on the screen.

bool LinkInRange(int dist_in_pixels);
 * Returns true if Link is within 'range' pixels of the enemy.

bool CanMove(int array[]);
 * Returns true if the npc can move in a given direction.
 * Uses an array literal for varying args.
 * Overloaded for a number of options:
 * 	{int dir}: Dir only, should use the default step distance.
 * 	{int dir, int special} 
 * 	{int ndir, int step, int special} 
 * 	{int ndir,int step,int special,int dx1,int dy1,int dx2,int dy2}

bool SimulateHit(int array[]); 
 * Simulates hitting the npc with a weapon, another sprite, or an arbitrary set of 
 * values passed as an overloaded array literal.
 * Returns true if that object would hit the npc. 
 * 	{TYPE, pointer} : Specify the type, such as PTR_TYPE_LWEAPON, then pass an object pointer.
 * 	{int tx, int ty, int tz, int txsz, int tysz, int tzsz} : Arbitrary values.
	
int LinedUp(int range, bool dir8);
 * Checks if enemy is lined up with Link.
 * If so, returns direction Link is at as compared to enemy.
	
npc Create(int array[]); 
 * Similar to Screen->CreateNPC(), except:
 * (1) It uses an arry literal for its args, with varying size.
 * (2) You can either create an npc only by its ID, or you can do
 * 	that and set its spawn coordinates at the same time.
 * (3) It works based on an existing pointer, such as:
 * 	npc n; n->Create{args});
 * Returns -1 if not lined up. Range is inclusive.
 * 	{ int id } 
 * 	{ int id, int x, int y }
	
void BreathAttack(bool seeklink);
 * Fires the breath weapon set to the enemy.

bool Collision(int obj_type, untyped obj_pointer);
 * Returns if either an object is colliding with the npc, or if an arbitrary set of 
 * coordinates would collide.
 * Valid Object Types:
 *obj_type_lweapon, obj_type_eweapon, obj_type_npc, obj_type_link, obj_type_ffc, obj_type_combo_pos, obj_type_item
 *** Not fully implemented!

	
int Family;
int Type;
 * The Family (Enemy Class) of the npc.

int Script; 
 * The npc action script used by this enemy.

untyped InitD[8];
 * The eight InitD args used by the npc action script for this enemy.

int ScriptTile;
 * If set to 0 or higher, then the npc will be drawn with this tile.
 * The default value for this is -1.

int ScriptFlip;
 * If set to 0, or higher, then the engine will use this Flip state to draw the npc.
 * The default value for this is -1. 
                                                        
untyped Attributes[32];
 * Epanded to size [32], and made datatype-insensitive.

int WeaponSprite;
 * The sprite (Quest->Graphics->Sprites->Weapons) used to draw the weapon fired by the npc.

bool Shield[5];
 * The shield state of the enemy. Index values:
 *
 *
 *
 *
 *


bool Core;
 * This returns true if the NPC is the core segment of a segmented engine enemy.

**************************************************************

untyped HitBy[10];
 * Stores the ID/UIDs of objects that hurt the npc this frame.
 * Indices:

 * The first four indices are for the *screen index* of objects:

 * Description		Index	Status
 * HIT_BY_NPC 		[0] 	Not used at this time. 
 * HIT_BY_EWEAPON 	[1] 	Not used at this time. 
 * HIT_BY_LWEAPON 	[2]	In use by the engine.
 * HIT_BY_FFC 		[3] 	Not used at this time. 

 * The next four, are for the FFCore 'script' UIDs of objects:

 * Description		Index	Status
 * HIT_BY_NPC_UID 	[4] 	Not used at this time. 
 * HIT_BY_EWEAPON_UID 	[5] 	Not used at this time. 
 * HIT_BY_LWEAPON_UID 	[6]	In use by the engine.
 * HIT_BY_FFC_UID 	[7] 	Not used at this time. 

 * The last two, are reserved for special damage-object types. 

 * Description		Index	Status
 * HIT_BY_COMBO 	[8]	Not used at this time. 
 * HIT_BY_MAPFLAG 	[9] 	Not used at this time. 

 * These indices are uniform across all HitBy[] array members, for any datatype with that member. 

 * Some lweapons, notably some melee weapons such as swords (but not sword beams), and boomerangs
 * are not yet implemented in this mechanic. 

**************************************************************

int Defense[42];
int Defense[MAX_DEFENSE];		
 * Expanded to a size of 42 to cover new defense categories.

untyped Misc[32];		
 * Epanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

float UID;
 * Each npc created by ZC in in a given session is assigned a unique ID (UID).
 * Returns the UID of an npc.
 * UIDs begin at 00000.0001 and overflow at 214748.3748. 
 *	Note: This allows for 2,147,483,748 unique npcs, per-session.

int InvFrames;				
 * Returns the number of remaining invincibility frames if the enemy is invincible, otherwise 0. 

int Invincible;			
 * Returns if the enemy is invincible, because of ( superman variable ). 

bool HasItem;				
 * Returns if the enemy is holding the screen item.

bool Ringleader;			
 * Returns if the enemy is a 'ringleader'.


/* The following commands are valid, but do not yet have in-engine use, */

int Frozen;
 * Returns the number of frames for which the npc remains frozen

int FrozenTile;
int FrozenCSet;

int npcscript;
 * The script ID used by this NPC.

untyped InitD[8];
 * InitialD for the npc script.

untyped IntiA[2];
 * InitialA for the npc script.

int Movement[32];
 * NPC Movement patterns, and args.

int WeaponPattern[32];
 * NPC weapon movement patterns and args.

int FireSound;
 * The sound that plays when the npc fires a weapon.

/************************************************************************************************************/

//////////////
///  Link  ///
//////////////

int Scale;
 * The scale factor for this sprited object. 
 * A scale of 0 and a scale of 1 are identical.
 * Scale values are a multiplier: 1.5 == 50% larger (150%).
 * Negative values are undefined.
 * You can only scale sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing.
 
int Rotation;
 * The rotation factor for this sprited object, in degrees.
 * You can only rotate sprites if you disable the Compatibility Quest rule 
   'Old (Faster) Sprite Drawing.

bool Item[256];
 * Reading from, or writing to this array no longer causes lag.

untyped Misc[32];		
 * Epanded from a size of [16] to [32]. An array of 32 miscellaneous variables for you to use as you please.
 * The Misc[] array now supports all datatypes, and has been expanded to a size of [32].

**************************************************************

untyped HitBy[10];
 * Stores the ID/UIDs of objects that hurt the Link this frame.

 * Indices:

 * The first four indices are for the *screen index* of objects:

 * Description		Index	Status
 * HIT_BY_NPC 		[0] 	In use by the engine. 
 * HIT_BY_EWEAPON 	[1] 	In use by the engine.
 * HIT_BY_LWEAPON 	[2]	Not used at this time.
 * HIT_BY_FFC 		[3] 	Not used at this time. 

 * The next four, are for the FFCore 'script' UIDs of objects:

 * Description		Index	Status
 * HIT_BY_NPC_UID 	[4] 	Not used at this time. 
 * HIT_BY_EWEAPON_UID 	[5] 	Not used at this time. 
 * HIT_BY_LWEAPON_UID 	[6]	Not used at this time.
 * HIT_BY_LWEAPON_UID 	[6]	Not used at this time.
 * HIT_BY_FFC_UID 	[7] 	Not used at this time. 

 * The last two, are reserved for special damage-object types. 

 * Description		Index	Status
 * HIT_BY_COMBO 	[8]	Not used at this time. 
 * HIT_BY_MAPFLAG 	[9] 	Not used at this time. 

 * These indices are uniform across all HitBy[] array members, for any datatype with that member. 

 * Some lweapons, notably some melee weapons such as swords (but not sword beams), and boomerangs
 * are not yet implemented in this mechanic. 

**************************************************************

int Stun;
 * Returns the number of frames for which Link will; remain stunned.
 * Writing to this causes Link to be stunned for 'n' frames.
 * This decrements once per frame.

int Pushing;
 * Returns the number of frames that Link has been pushing against a solid object.

int Defense[]; 
 * Unused at this time.

int ScriptTile;
 * If this is > 0, then Link will be drawn using this tile ID.
 * The specific tile is drawn. This is not an offset, nor OTile.

int ScriptFlip;
 * If this is > 0, then Link's tile will be drawn using this flip value.

bool DisableItem[256];
 * An array of 256 values that represents whether items are disabeld on the current DMap.

int InvFrames;				 
 * This returns how long Link will remain invincible, 0 if not invincible. Can be set. 

bool InvFlicker;			
 * If set false, Link will neither flash, nor flicker when invincible. 

int HurtSound;				
 * The sound that plays when Link is injured. By default this is '16', but you may change it at any time.  

int Eaten;				
 * It returns 0 if Link is not eaten, otherwise it returns the duration of him being eaten.

int Equipment;				
 * Link->Equipment is now read-write, and needs testing.

int ItemA;				
 * Contains the item IDs of what is currently equiped to Link's A button.

int ItemB;				
 * Contains the item IDs of what is currently equiped to Link's B button.

int SetItemSlot(int itm_id, int button, int force);				
 * This allows you to set Link's button items without binary operation with options for forcing them.

int UsingItem;			
 * Returns the ID of an item used when Link uses an item. Returns -1 if Link is not using an item this frame. 

int UsingItemA;		
 * Returns the ID of an item used when Link uses an item on button A. Returns -1 if Link is not using an item this frame. 

int UsingItemB;	
 * Returns the ID of an item used when Link uses an item on button B. Returns -1 if Link is not using an item this frame. 

bool Diagonal;	
 * This corresponds to whether 'Diagonal Movement' is enabled, or not. 

bool BigHitbox;		
 * This corresponds to whether 'Big Hitbox' is enabled, or not. 
	
int Attack; 

/* The following have not been ported from 2.future to Canonical ZC:

	int Animation;				
	* Link's Animation style, as set in Quest->Graphics->Sprites->Link
						
	int WalkASpeed;				
	* Link's Walking Animation speed as set in Quest->Graphics->Sprites->Link

	int SwimASpeed;				
	* Link's Swiming Animation speed as set in Quest->Graphics->Sprites->Link

	int HitHeight;				
	* link's Hitbox height in pixels starting from his 0x,0y (upper-left) corner, going down. 
			
	int HitWidth;				
	* Link's Hitbox width in pixels starting from his x0,y0 (upper-left) corner, going right. 

	int HitXOffset;				
	* The X offset of Link's hitbox, or collision rectangle.
		
	int HitYOffset;				
	* The Y offset of Link's hitbox, or collision rectangle.

	int Extend;			
	* Sets the extend value for all of Link's various actions.
*/

void WarpEx(int ptr[])

* Similar to Link->Warp, but with more options. This takes an array, or
  an array literal as its arguments. 
  
  Valid array params are:
	Link->WarpEx({type,dmap,screen,x,y,effect,sound,flags})
	and
	Link->WarpEx({type,dmap,screen,x,y,effect,sound,flags,forcedir}

	type:
		Warp types are:
			wtIWARP: Acts like a tile warp.
			wtExit: An entrance/exit warp.
			wtSCROLL: A scrolling warp.
			wtNONE: A cancel warp. 
			
	dmap:
		The Destination DMap
		
	screen: 
		The Destination Screen
		
	x, y:
		Either raw pixel coordinates, or a warp return square ID.
		
			Link->WarpEx() Coordinates Versus Warp Return Square:
				If 'x' and 'y' are both > -1, then they are raw coordinates as always.
				If 'x' < 0, THEN 'y' is the warp return square type, using positive integers.

				This allows using the warp return constants in std.zh, and it prevents a 
				possible ID clash from both values trying to establish the square ID. 

	effect:
		Warp Effects are:
		warpEffectNONE: No visual effect.
		warpEffectZap: Zap Effects
		warpEffectWave: Wave Effects
		warpEffectInstant: Black screen.
		warpEffectOpen: Calls the opening wipe.

	sound:
		You may play a special sound (e.g. Magic Mirror) during the warp.

	flags:
		Warp Flags are:
		warpFlagKILLSCRIPTDRAWS: Don't kill script drawing during the warp.
		warpFlagKILLSOUNDS: Don't kill playing sounds during the warp.
		warpFlagKILLMUSIC: Don't kill playing music during the warp.

		Their values are:
		warpFlagKILLSCRIPTDRAWS 0x01
		warpFlagKILLSOUNDS 0x02
		warpFlagKILLMUSIC 0x04

		Add them together to calculate a flag.

	forcedir:
		You can either accept the engine's setting for what Link's Dir should be
		after warping him, or force a dir.




/************************************************************************************************************/

//////////////////
///  itemdata  ///
//////////////////

int ID;		
 * Returns the item number of the item in question.

void RunScript(bool perpetual);
 * Runs the script assigned to this item at any arbitrary time.
 * If (perpetual == true), then the script will continue running for more than
 *	one frame, even if the QR is off. If the QR 'Item Scripts Continue Running'
 *	is enabled, then this boolean does nothing.

int Family;
int Type;
 * The Family (Item Class) of the item.

int WeaponScript;
 * The weapon action script assigned to this item.

int WeaponInitD[8];
 * The eight InitD args used by the weapon script forr this item.

int Modifier;	
 * The Link Tile Modifier

int Tile;	
 * The tile used by the item.

int CSet;	
 * The CSet of the tile used by the item.
	
int Flash;		
 * The Flash value for the CSet
	
int AFrames;		
 * The number of animation frames in the item's tile animation. 

int ASpeed;		
 * The speed of the item's animation.
	
int Delay;	
 * The Delay value, before the animation begins. 

int Script;		
 * The Action Script for the item.

int PScript;	
 * The Pickup Script for the item.

int MagicCost;	
 * The item's magic (or rupees, if this is set) cost.

int MinHearts;		
 * The minimum number of hearts required to pick up the item.

float Attributes[10] 
 * An array of ten integers that correspond to the ten <Misc> text entries on the item editor Data tab.
 * Now datatype-insensitive.

int Sprites[10]
 * An array of ten integers that correspond to the ten sprite pulldowns on the item editor Action tab.

bool Flags[5]
 * An array of five boolean flags that correspond to the five flag tickboxes on the item editor Data tab.

bool Combine;	
 * Corresponds to 'Upgrade when collected twice'.
	
bool Downgrade;	
 * Corresponds to the 'Remove When Used' option on the Action tab of the item editor. 
	
bool KeepOld;
 * Corresponds to 'Keep lower level items on the Pickup tab of the item editor. 
	
bool RupeeCost;	
 * Corresponds to the 'Use Rupees Instead of Magic' option on the item editor 'Action' tab.
 * Deprecated by CostCounter.
	
bool Edible;	
 * Corresponds to the 'Can be Eaten by Enemies' box on the Pickup tab of the item editor. 
	
bool GainLower;	
 * Corresponds to the 'Gain All Lower Level Items' box on the Pickup tab of the item editor. 

untyped InitD[8];
 * The eight D* args used by both item scripts. Accepts all datatypes.

int Family;
 * The item class.

int Level;
 * The item's Level.

int Power; 
 * The amount of damage generated by the primary weapon for this item, if any.

int Amount;
int Max; 
int MaxIncrement;
int Keep;
int Counter; //should be renamed to IncreaseCounter

int MagicCostTimer //needsto be CostTimer
 * The number of frames between counter decrements, when using an item with a perpetual 
 * 	upkeep cost, such as Boots and Cane items.

int UseSound;
 * The sound that will play when the item is used.

int Pickup; 
 * The Pickup type for this item See IP_* in std_constants.zh.
	
int PickupFlags;
 * A flagset used by the Item Editor UI to determine special conditions for item pick-up.
 * Values are ORd together:
 *
 *

int PickupString;
 * The ZQ String Editor (message) string that will appear when Link collects this item.
 * Note: The exact nature of hw frequently the string will be shown per game session can be
 *	modified using 'int PickupStringFlags'.

int PickupStringFlags;
 * A flagset that determines how frequently the PickupString for an item is displayed per game session.
 * You may set the string to always show, only show once per game session, or other intervals
 * using the following flagset (values are ORd together):
 *
 *
 *

int Cost; //may need to rename MagicCost, to Cost
 * The cost of the item, in units. Whenever the item is used, this value is decremented from 
 * 	the counter supplied to 'CostCounter'. 
 * If the item runs for more than one frame, this amount will be decremented every n frames,
 * 	where n is the value of 'CostTimer'.

int CostCounter;
 * The counter to use when decrementing the item cost. The default is 'CR_MAGIC'.
 * Some item classes (e.g. Bombs) reduce a counter, whether this is set or not.
 * In the case that this is set on such an uitem, it acts as a secobdary cost.

int DrawXOffset;
 * The horizontal draw offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.
	
int DrawYOffset;
 * The vertical draw offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitXOffset;
 * The horizontal hitbox offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitYOffset;
 * The vertical hitbox offset of the item. 
 * Note: SizeFlags[??] must be enabled for this to function.

int HitWidth;
 * The hitbox width (X component), in pixels, for the enemy.
 * Note: SizeFlags[??] must be enabled for this to function.

int HitHeight;
 * The hitbox height (Y component), in pixels, for the enemy. 
 * Note: SizeFlags[??] must be enabled for this to function.

int TileWidth;
 * The drawn width (X component) of the item in increments of one tile.
 * Note: SizeFlags[??] must be enabled for this to function.
	
int TileHeight;
 * The drawn height (Y component) of the item in increments of one tile.
 * Note: SizeFlags[??] must be enabled for this to function.

int OverrideFlags;
 * ? Is this the same as SizeFlags? 

int SizeFlags;
 * A flagset that determines which Item Editor 'Size' tab attribute values are applied to the
 * item, overriding engine defaults.

int CollectFlags;
 * ?

void GetName(int buffer[]);
 * Loads the item's name into 'buffer'.

//Unimplemented for Weapon Editor: 
int Weapon;
int Defense;
int Range;
int Duration;
untyped WeaponD[8];
untyped WeaponMisc[32];
int Duplicates;
int DrawLayer; 
int CollectFlags;
int WeaponScript;
int WeapomnHitXOffset;
int WeaponHitYOffset;
int WeaponHitHeight;
int WeaponHitWidth;
int WeaponHitZHeight;
int WeaponDrawXOffset; 
int WeaponDrawYOffset;
int WeaponDrawZOffset;
int WeaponOverrideFlags;

t/b/a
itemdata GetItem(name[]);

/************************************************************************************************************/

/////////////////////
///  messagedata  ///
/////////////////////

void Set(int buffer[]);
 * Assigns the ZString buffer[] to the messagedata pointer's string.

void Get(int buffer[]);
 * Copies the string value from the messagedata pointer, to the array buffer[].


int buffer_str[80];

int Next;
 * Next message in list.

int Tile;
int CSet;
int Font;
int X;
int Y;
int Width;
int Height;
int Sound;
int ListPosition;
int VSpace;
int HSpace;
int Flags;
bool Transparent; (unused at this time).
	
//////////////////
///  dmapdata  ///
//////////////////

	1.	Sideview Gravity on All Screens (uses Dmaps[].sideview, new var.
	2.	Layer 3 is Background on All Screens (uses DMaps[].flgs&dmfLAYER3BG)
	3.	Layer 2 is Background on All Screens (uses DMaps[].flgs&dmfLAYER2BG
	
int Map;
int Level;
int Offset;
int Compass;
int Palette;
int MIDI;
int Continue;
int Type;
int MusicTrack;
int ActiveSubscreen;
int PassiveSubscreen;
int Grid[8];
int MiniMapTile[2];
int MiniMapCSet[2];
int MapTile[2];
int MapCSet[2];
int DisabledItems[256];
int Flags;
bool Sideview;
	
void SetName(int buffer[]);
void GetName(int buffer[]);
void SetTitle(int buffer[]);
void GetTitle(int buffer[]);
void SetIntro(int buffer[]);
void GetIntro(int buffe[]);

void SetMusic(); //enh music
void GetMusic();


//////////////////
///  shopdata  ///
//////////////////

	shop->Price[3]
	infoshop->Price[3]
	infoshop->String[3]
	shop->Item[3]
	shop->HasItem[3]

/////////////////
///  mapdata  ///
/////////////////

int Script; 
 * Returns the ID of the script set to the mapscreen, or sets the script that this mapscreen runs.
 
untyped InitD[8];
 * The eight script args for the script that runs on this mapscreen.

bool isSolid(int x, int y);
 * As Screen->isSolid(int x, int y), for any mapscreen.

int Valid;
 * ?

int Guy;
 * The screen guy.

int String;
 * The screen string.

int RoomType;
 * The screen room type.

int Item; 
 * The screen item.
 * Note: The NULL value is '0', which is a valid item.
 * 	To determine if there is an item on the screen, if you ever assigned
 * 	item 0 as a valid screen item in your quest, you will also want to read
 * 	HasItem for that screen.

int HasItem;
 * If not zero, then the item for this screen will be shown.
 * When Link takes the item on a screen, this is set to 0.

int TileWarpType[4];
 * The Tile Warp type for Tile Warps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh TWTYPE_* constants for valid types.
	
int TileWarpOverlayFlags;
 * Combos carry over?

int DoorComboSet;
 * The doorset used by the screen, for NES dungeon doors.
	
int WarpReturnX[4];
 * The X-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnY[4];
 * The Y-component for each of the four 2.50+ (blue) warp return squares.
	
int WarpReturnC;
 * ?

int StairsX;
 * The X component for where a Stairs secret appears on the screen.
	
int StairsY;
 * The Y component for where a Stairs secret appears on the screen.
	
int ItemX;
 * The X component for the item location on the screen.
	
int ItemY;
 * The Y component for the item location on the screen.

int CSet;
 * ? The screen palette. ?

int Door[4];
 * The door state for the screen. See D_* constants for direction and door type.
	
int TileWarpDMap[4];
 * The destination DMap for each of the four warp types.
	
int TileWarpScreen[4];
 * The destination screen for each of the four warp types.

int Enemy[10];
 * The IDs of the enemies that spawn on the screen.

int EnemyFlags;
 * A flagset for enemies on the screen (E.Flags).
 * Valid values (ORd) together, are:
 *
 *

int Pattern;
 * This enemy 'Spawn Pattern'.

int SideWarpType[4];
 * The Sidewarp type for Sidewarps A, B, C, and D; [0], [1], [2], and [3] respectively.
 * See std_constants.zh SWTYPE_* constants for valid types.
	
int SideWarpOverlayFlags;
 * Carryover?

int SideWarpScreen[4];
 * The destination screen for each of the four sidewarps.
	
int SideWarpDMap[4];
 * The destination DMap for each of the four sidewarps.
	
int SideWarpIndex;
 * The warp return?? If so, should this be an array, or are these ORd values?

int WarpArrivalX;
 * The X-component for the pre-2.50 (green) arrival square.
	
int WarpArrivalY;
 * The X-component for the pre-2.50 (green) arrival square.
	
int MazePath[4]; 
 * The four Maze Path directions.

int ExitDir;
 * The Maze Path 'Exit Direction'.

int UnderCombo;
 * The undercombo ID used by the screen.

int UnderCSet;
 * The CSet of the undercombo used by the screen.

int Catchall;
 * The screen 'Catchall' value. 

int CSensitive;
 * The value of Damage Combo Sensitivity for the screen.
	
int NoReset;
 * The No Reset Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x
 * Door Up [0]		0x
 * Door Down[1]		0x
 * Door Left [2]	0x
 * Door Right [3]	0x

int NoCarry;
 * The No Carry Over Flagset. Values are ORd together s follows:
 * Secrets		0x
 * Items		0x
 * Special Item		0x
 * Lock Block		0x
 * Boss Lock Block	0x
 * Chest		0x
 * Secrets		0x
 * Locked Chest		0x
 * Boss Locked Chest	0x

int LayerMap[7];
 * The Map IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerScreen[7];
 * The Screen IDs used by screen layers 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int LayerOpacity[7];
 * The opacity value for each layer used by this screen.
 * Valid layers are 1 through 6, represented as [1] through [6].
 * Index [0] does nothing, and trying to access it will report an error to the log.

int TimedWarpTimer;
 * The timer used by 'Time Warp Tics' in Screen Data->T.Warp

int NextMap;
 * ?

int NextScreen;
 *?

int SecretCombo[128];
 * The Combo IDs used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretCSet[128];
 * The CSets used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int SecretFlags[128];
 * The Combo Flags used by 'Secret Combos' on this screen.
 * See SCR_SEC_* in std_constants.zh for more information.
	
int ViewX;
 * Unused at this time. Represents the visible width of the screen.

int ViewY;
 * Unused at this time. Represents the visible height of the screen.

int Width;
 * Unused at this time. Represents the physical;e width of the screen.

int Height;
 * Unused at this time. Represents the physical height of the screen.

int EntryX;
 * The X-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this X-component. 

int EntryY;
 * The Y-coordinate at which Link entered the screen (his last spawn point).
 * If Link is respawned by falling in water, he will appear at this Y-component. 

int ScriptEntry;
 * ?

int ScriptOccupancy;
 * ?

int ExitScript;
 * ?

int OceanSFX;
 * The 'Ambient Sound' under S.Data2. 
 * Rename this to AmbientSFX, or just SFX.

int BossSFX;
 * The Boss Roar sound for this screen.
	
int SecretSFX;
 * The sound that will play on this screen, when secrets are triggered.

int ItemSFX;
 * The sound that will play if Link holds an item over his head on this screen.
	
int MIDI;
 * The MIDI that plays on this screen.

int LensLayer;
 * The layer to which Lens of Truth graphics are drawn.

int Flags[10];
 * A set of flagsets that contain special data for thiws screen.
 * These represent S.Flags1 and S.Flags2 flags.
 * See std_constants.zh (SFG* for the screen flag froup, 
 *	and SFX* for the screen flag value) for more information. 
	
int D[8];
 * Improperly implemented. Was meant to relate as Screen->D, except that
 * 	Screen->D is not bound to layermap.

int ComboD[176];
 * The IDs of each of the 176 combos used on the screen.

int ComboC[176];
 * The CSets of each of the 176 combos used on the screen.

int ComboF[176];
 * The placed (map) flags for each of the 176 combo positions used by this screen.

int ComboS[176];
 * The inherent flags of each of the 176 combos used on the screen.

int State[32];
 * The screen states used by this screen. Identical to Screen->State[], but for mapdata screens.

int EFlags[3];
 * The Screen Data E.Flags flagsets. 
 * Values are:
 *

int NumFFCs;
 * ? The number of ffcs running scripts?

int FFCEffectWidth[32];
 * The EffectWidth variable for each of the 32 ffcs on the screen.
 * See ffc->EffectWidth for more details. 
		
int FFCEffectHeight[32];
 * The EffectHeight variable for each of the 32 ffcs on the screen.
 * See ffc->EffectHeight for more details. 
	
int FFCTileWidth[32];
 * The TileWidth variable for each of the 32 ffcs on the screen.
 * See ffc->TilwWidth for more details. 
	
int FFCTileHeight[32];
 * The TileHeighr variable for each of the 32 ffcs on the screen.
 * See ffc->TilwHeight for more details. 

int FFCData[32];
 * The Data (combo ID) variable for each of the 32 ffcs on the screen.
 * See ffc->Data for more details. 
	
int FFCCSet[32];
 * The CSet variable for each of the 32 ffcs on the screen.
 * See ffc->CSet for more details. 
	
int FFCDelay[32];
 * The Delay variable for each of the 32 ffcs on the screen.
 * See ffc->Delay for more details. 
	
int FFCX[32];
 * The X variable for each of the 32 ffcs on the screen.
 * See ffc->X for more details. 
	
int FFCY[32];
 * The Y variable for each of the 32 ffcs on the screen.
 * See ffc->Y for more details. 
	
int FFCVx[32];
 * The Vx variable for each of the 32 ffcs on the screen.
 * See ffc->Vx for more details. 
	
int FFCVy[32];
 * The Vy variable for each of the 32 ffcs on the screen.
 * See ffc->Vy for more details. 
	
int FFCAx[32];
 * The Ax variable for each of the 32 ffcs on the screen.
 * See ffc->Ax for more details. 
	
int FFCAy[32];
 * The Vy variable for each of the 32 ffcs on the screen.
 * See ffc->Vy for more details. 
	
int FFCFlags[32];
 * The Flags variable for each of the 32 ffcs on the screen.
 * See ffc->Flags for more details. 
	
int FFCLink[32];
 * The Link variable for each of the 32 ffcs on the screen.
 * See ffc->Link for more details. 
	
int FFCScript[32];
 * The Script variable for each of the 32 ffcs on the screen.
 * See ffc->Script for more details. 
	
bool FFCRunning[32];
 * Returns true if the specified ffc is running a script?
 * May be used to pause/resume ffc script execution?
 * This needs to be cloned over to ffc->Running -Z

 //Functions
int GetFFCInitD(int ffc_index, int n);
 * Returns the value of InitD[n] for the ffc on the screen with an ID of ffc_index.
 * This needs to be converted to the type 'untyped' to comply
 * 	with the change of float ffc->InitD[] to untyped ffc->InitD[]
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitD[32][8].

void SetFFCInitD(int ffc_index, int n, float value);
 * Sets the value of InitD[n] for the ffc on the screen with an ID of ffc_index.
 * 'int value' needs to be converted to the type 'untyped' to comply
 * 	with the change of float ffc->InitD[] to untyped ffc->InitD[]
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitD[32][8].


int GetFFCInitA(int ffc_index, int n);
 * Returns the value of InitA[n] for the ffc on the screen with an ID of ffc_index.
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitA[32][2].


void SetFFCIniA(int ffc_index, int init_a, float value);
 * Sets the value of InitA[n] for the ffc on the screen with an ID of ffc_index.
 * 	Note: Expressed as a function due to lack of 2D arrays in ZScript. 
 * 	With 2D arrays, this would simply be FFCInitA[32][2].




///////////////////
///  combodata  ///
///////////////////

int Type; 
 * The 'type' of the combo, in the Combo Editor. 
 * Setting this changes the combo type variables. ?

int Tile; 
 * The tile ID used by the combo.

int Flip; 
 * The flip settings for the combo tile.
	
int Walk;
 * The walkability flags value. 
 * Walk flags are OR'd together using values of:
 *	
 *	

int CSet; 
* The CSet values for the combo.
 * 	How is CSet2 stored?

int Foo; 
 * Unused.

int Frames; 
 * The number of frames of animation.

int NextData;
 * 

int NextCSet; 
 *

int NextTimer; 
 *

int Flag; 
 * The inherent flag bound to the combo.

int SkipAnim; //needs to be renamed to SkipAnimX
 * Corresponds to 'A.SkipX' in the Combo Editor.

int SkipAnimY; 
 * Corresponds to 'A.SkipX' in the Combo Editor.

int AnimFlags;
 * This contains flag data for the Combo Editor settings:
 *	0x	Refresh Animation on Room Entry
 * 	0x 	Refresh Animation When Cycled To

int Expansion[6]; 
 * Reserved for future use by the Combo Editor.
	
int Attributes[4]; 
 * Corresponds to Attributes[0] through Attributes[3] on the 'Attributes'
 * 	tab in the Combo Editor.

int UserFlags;
 * Corresponds to the 'Misc Flags' on the Attributes tab of the Combo Editor.
 * These values are ORd together.

int TriggerFlags[3]; 
 * Corresponds to the flags on the 'Triggered By' tabs of the Combo Editor
 * 	where the indices and flag values are:
 *	
 *	

int TriggerLevel; 
 * Corresponds to the 'Minimum Level' field on the 'Triggered By (1)' tab of 
 *	the Combo Editor.

/* Combo Types
*	These values contain data that is used by ZC to determine the Combo Type.
*	Using combodata in ZScript, it is possible to define wholly new types
*	by combining sets of these values.
*/

int BlockNPC; 
int BlockHole; 
int BlockTrigger; 
int BlockWeapon[32];
int ConveyorSpeedX; 
int ConveyorSpeedY; 
int SpawnNPC; 
int SpawnNPCWhen; 
int SpawnNPCChange;
int DirChange; 
int DistanceChangeTiles; 
int DiveItem; 
int Dock; 
int Fairy; 
int FFCAttributeChange; 
int DecorationTile; 
int DecorationType; 
int Hookshot;
int Ladder; 
int LockBlock; 
int LockBlockChange; 
int Mirror; 
int DamageAmount; 
int DamageDelay;
int DamageType; 
int MagicAmount; 
int MagicDelay; 
int MagicType; 
int NoPushBlocks;
int Overhead; 
int PlaceNPC; 
int PushDir; 
int PushDelay; 
int PushHeavy; 
int Pushed; 
int Raft;
int ResetRoom; 
int SavePoint; 
int FreezeScreen; 
int SecretCombo; 
int Singular (self-only);
int SlowWalk; 
int Statue; 
int Step; 
int StepChange; 
int Strike[32]; 
int StrikeRemnants;
int StrikeRemnantsType; 
int StrikeChange; 
int StrikeItem; 
int TouchItem;	
int TouchStairs; 
int TriggerType; 
int TriggerSensitivity; 
int Warp; 
int WarpSensitivity;
int WarpDirect; 
int WarpLocation; 
int Water; 
int Whistle; 
int WinGame; 
int BlockWeaponLevel;

// t/b/a
//void GetLabel() / GetName()
//void SetLabel / SetName()
//combodata GetCombo(int label[])
//int Game->GetCombo(int name[])

	triggerflags[3]
	combodata->Attributes[] and Screen->GetComboAttribute(pos, indx) / SetComboAttribute(pos, indx)
	combodata->Flags and Screen->ComboFlags[pos] -- Maybe ComboMisc[pos] to avoid confusion?
	Combo QR rules will become ComboMisc[] ! 

////////////////////
///  Graphics->  ///
////////////////////

int GetPixel(bitmap b, int x, int y);
 * Returns the palette index value for a pixel on a bitmap, at coordinates x, y on that bitmap.
 * The value is expressed as float at this time. 

int NumDraws();
 * Returns the number of script draws that have been executed during the current frame.
 
int MaxDraws();
 * Returns the maximum number of script draws per frame that you can execute in the current build.
 
void Monochrome(int mode);
 * Sets the entire display to monochrome output, using a hue mode that you may select, and either distributed,
 * or uniform colour distribution.
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void MonoHue(int red, int green, int blue, bool distributed);
 * Sets the entire display to monochrome output, using either distributed using a uniform mode, or
 * a differential mode selected from `bool distributed`, using a hue based on the values that you supply
 * as `red`, `green`, and `blue`. 
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void Tint(int red, int green, blue);
 * Tints the entire display with a palette shift using the values that you supply as `red`, `green`, and `blue`.
 * This respects the current DMap (level) palette, and it affects the entire main game palette. 

void ClearTint();
 * Clears all tints, and monochrome/greyscale states back to the original game palette, and normalises it for
   the given DMap palette. 

void Wavy(bool wavyin); 
 * Creates a wavy visual effect, identical to 'Wavy' Warp effects.
 * There are two styles, 'WavyIn', and 'WavyOut'. Select from these using parameter 1. 

void Zap(bool zapin);
 * Creates a wavy visual effect, identical to 'Zap' Warp effects.
 * There are two styles, 'ZapIn', and 'ZapOut'. Select from these using parameter 1. 

void Greyscale(bool enable);
 * Converts the game to monochrome greyscale, or reverts from greyscale to colour.
 * This is useful for simulating 'Gameboy' style displays.
	

/////////////////
///  Audio->  ///
/////////////////

void PlayOgg(int filename[]);
 * Similar to PlayEnhancedMusic(), but only for OGG files.
 * Supports seeking, and other special instructions.

int GetOggPos();
 * Returns the current seek position of an OGG started with PlayOgg, in ms.

void SetOggPos(int new_pos);
 * Sets the play position for an OGG started with PlayOgg(), in ms.
 
void SetOggSpeed(int newspeed);
 * Sets the playback speed of an OGG started with PlayOgg();
 

void PlaySound(int soundid);	ZASM Instruction: 
					PLAYSOUNDR
					PLAYSOUNDV
	/**
	* Plays one of the quest's sound effects. Use the SFX_ constants in
	* std.zh as values of soundid.
	*/ Example Use: !#!
	
void EndSound(int soundid);
 * If sfx_id is playing, calling this immediately stops that sound.

void PauseSound(int soundid);
 * If sfx_id is playing, calling this pauses it, halting it from playing, in
 * a manner that you may later resume it from the point at which it was paused.
 * See also: Audio->ResumeSound(int sfx_id) and Audio->ContinueSound(int sfx_id).

void ResumeSound(int soundid); 
 * Resumes a sound effect with an ID of sfx_id, that has been paused.

void ContinueSound(int soundid);
 * Resumes a sound effect with an ID of sfx_id, that has been paused.

void AdjustMusicVolume(int percent); 
 * Adjusts the volume of all MIDI, DIGI, and Enhanced Music.
 * The parameter 'int percent' is the percentage of its present volume.
 * To double the volume, you would pass '200' to parameter 1; to reduce it by half, you
 *	would pass '50' to parameter 1.

void AdjustSFXVolume(int percent);
 * Adjusts the volume of all Soune Effects (WAV).
 * The parameter 'int percent' is the percentage of its present volume.
 * To double the volume, you would pass '200' to parameter 1; to reduce it by half, you
 *	would pass '50' to parameter 1.

void AdjustSound(int, int, bool)

void PauseCurMIDI();
 * Pauses the current MIDI in a manner that permits resuming it.
 * Note: This does not affect Enhanced Music playback.
 * See also: Audio->ResumeCurMIDI().

void ResumeCurMIDI();
 * Resumes MIDI playback, if it has been paused.
 * Note: This does not affect Enhanced Music playback.
 * See also: Audio->PauseCurMIDI().

void PlayMIDI(int MIDIid);	ZASM Instruction: 
					PLAYMIDIR
					PLAYMIDIV
	/**
	* Changes the current screen MIDI to MIDIid.
	* Will revert to the DMap (or screen) MIDI upon leaving the screen.
	*/ Example Use: !#!

bool PlayEnhancedMusic(int filename[], int track);
		
					ZASM Instruction: 
					PLAYENHMUSIC
	/**
	* Play the specified enhanced music if it's available. If the music
	* cannot be played, the current music will continue. The music will
	* revert to normal upon leaving the screen.
	* Returns true if the music file was loaded successfully.
	* The filename cannot be more than 255 characters. If the music format
	* does not support multiple tracks, the track argument will be ignored.
	*/ Example Use: 
	
		int music[]="myfile.mp3"; // Make a string with the filename of the music to play.
		if ( !Game->PlayEnhancedMusic(music, 1) ) Game->PlayMIDI(midi_id);
		
		// Plays the enhanced music file 'myfle.mp3', track 1. 
		// If the file is mssing, the game will instead play 
		// the midi specified as midi_id.

int PanStyle;
 * Set or get the audio panning. See PAN_* constants in std_constants.zh for valid values.

//int Volume[4]
 * Deprecated; raw access to the UI audio controls. (Now unsupported officially.)

////////////////
///  Text->  ///
////////////////

t/b/a

/////////////////
///  Input->  ///
/////////////////

int ModifierKeys;
 * Returns the Allegro Keyboard Modifier Flags:
 *	KB_SHIFT_FLAG = 0x0001;
 *	KB_CTRL_FLAG = 0x0002;
 *	KB_ALT_FLAG = 0x0004;
 *	KB_LWIN_FLAG = 0x0008;
 *	KB_RWIN_FLAG = 0x0010;
 *	KB_MENU_FLAG  = 0x0020;
 *	KB_COMMAND_FLAG  = 0x0040;
 *	KB_SCROLOCK_FLAG  = 0x0100;
 *	KB_NUMLOCK_FLAG = 0x0200;
 *	KB_CAPSLOCK_FLAG = 0x0400;
 *	KB_INALTSEQ_FLAG = 0x0800;
 *	KB_ACCENT1_FLAG = 0x1000; 
 *	KB_ACCENT2_FLAG = 0x2000; 
 *	KB_ACCENT3_FLAG = 0x4000; 
 *	KB_ACCENT4_FLAG = 0x8000; 
 * I am unsure what 0x80 is, if anything. It is not listed in Allegro keyboard.h. -Z
 * Might have been reserved for the Apple Right Command key, but never used. 
 
int KeyBindings[14];
 * Returns the key bound to the 14 possible system keys.
 * Use the CB_* constants to access the array, and the KEY_*
 * constants for values. 
 
bool SimulateKeypress[127];
 * Simulates pressing a key on the keyboard, where the key_id
 * is the index of the array. 
 * Input->SimulateKeypress[KEY_A] = true; will attempt to simulate 
 * the user pressing the A key on their keyboard.
 * Writing this false has no effect. 

bool Press[18];
 * An array of boolean values that correspond to whether a control button, or a keyboard
 * 	key bound to a control button, was pressed this frame.
 *	Replaces Link->Press*.
 * Use the CB_* constants to access this array. 

bool Button[18];
 * An array of boolean values that correspond to whether a control button, or a keyboard
 * 	key bound to a control button, was held down this frame.
 *	Replaces Link->Input*.
 * Use the CB_* constants to access this array. 
 
bool Hold[18];
 * An array of boolean values that correspond to whether a control button, or a keyboard
 * 	key bound to a control button, was held down this frame.
 * May be identical to Input->Press[] in some regards.
 * Use the CB_* constants to access this array. 
 
bool Key[127];
 * Read-Only: An array of boolean values that read as 'true'
 * 	if the corresponding keyboard key was pressed this frame.
 * You can write a key false, but not true. 
 * Use the KEY_* constants to access this array. 
	
ReadKey[127] ( should become a function ReadKey()? )
 * As Key[], except that reading a key with ReadKey[] will ignore further input from that key, 
   until it is released. 
 * Read-only.
 * Use the KEY_* constants to access this array. 
 
bool Joypad[18]; //this is erroneously set up as TYPE_FLOAT in the parser.
 * Similar to Press, except that it only returns presses from a joystick device, not a keyboard.
 * Use the CB_* constants to access this array. 
 
float Mouse[6];
 * An array of boolean values that correspond to whether a mouse button, was clicked this frame,
   plus the x/y components of the mouse.
 *	Replaces mouse variables under Link->.
 * indices: 
 * 	float Mouse[0] Mouse X Position
 * 	float Mouse[1] Mouse Y Position
 * 	float Mouse[2] Mouse Z Position
 * 	bool Mouse[3] Left Button
 * 	bool Mouse[4] Right Button
 * 	bool Mouse[5] Middle Button


//int Type //this is a dummy function in the table.
	
/////////////////
///  npcdata  ///
/////////////////

/*
The npcdata datatype allows the user to load and manipulate Enemy Editor
data, and to r/w that information.

Like itemdata, this persists only until the quest exits.

To use npcdata, you must declare an npcdata typed pointer, then load a npc ID
to that pointer. 

npcdata nd = Game->LoadNPCData(1); // Load enemy ID 1 to the pointer 'nd'.

From here, you may access the member functions, and variables as normal:

nd->HP = 32;

*/

void GetName(int ptr[]);
 * Puts the text of the Enemy Name field into string 'ptr'.

void GetInitDLabel(int ptr[], int d_index);
 * Puts the text of the InitD label 'd_index' into string 'ptr'.

bool MatchInitDLabel("label", int d_index);
 * Compares string 'label' to the text of the InitD label field 'd_index'.
 * Returns true if they match.
 * Should be slightly faster than strcmp().

int Family;
int Type;
 * The Family (Enemy Class) of the npc.

int Script; 
 * The npc action script used by this enemy.

untyped InitD[8];
 * The eight InitD args used by the npc action script for this enemy.

int WeaponScript;
 * The weapon action script assigned to this enemy.

untyped WeaponInitD[8];
 * The eight InitD args assigned to the weapon script used by this enemy.

int Tile;
 * The base tile used by the enemy.

int Flags, 
int Flags2, 

int Width;
 * The 'width' (W) of base tile used by the enemy.

int Height;
 * The 'height' (H) of base tile used by the enemy.

int STile;
 * The base 'special' tile used by the enemy.

int SWidth;
 * The 'width' (W) of base 'special' tile used by the enemy.

int SHeight;
 * The 'height' (H) of base 'special' tile used by the enemy.

int ExTile;
 * The base EXPANDED ('New') tile used by the enemy.

int ExWidth;
 * The 'width' (W) of base EXPANDED ('New') tile used by the enemy.

int ExHeight;
 * The 'height' (H) of base EXPANDED ('New') tile used by the enemy.

int HP;
 * The enemy's base hit points.

int Family;
 * The 'Type' of the enemy.

int CSet, 
 * Thge CSet used to render the enemy.

int Anim;
 * The 'O.Anim' used by the enemy.

int ExAnim;
 * The 'E.Anim' used by the enemy.

int Framerate;
 * The 'O.Anim' animation framerate used by the enemy.

int ExFramerate;
 * The 'E.Anim' animation framerate used by the enemy.

int TouchDamage;
 * The amount of contact damage that the enemy causes when it collides with Link.

int WeaponDamage;
 * The power of the weapons fired by the enemy.

int Weapon;
 * The weapon type used by the enemy.

int Random;
 * The 'random rate' of the enemy.

int Haltrate;
 * The 'turn frequency' used by the enemy during its movement phase.

int Step;
 * The enem's step speed.

int Homing;
 * The homing factor of the enemy. Greater values home more keenly on Link. 

int Hunger;
 * The 'hunger' value of the enemy. 
 * Higher values make it more likely that the enemy is attracted to Bait.
 * Valid only for NPCT_WALKING enemies.

int Dropset;
 * The dropset used by the enemy.

int BGSFX;
 * The Ambient sound that the enemy emits.

int DeathSFX;
 * The sound that is played when the enemy dies.

int HitSFX;
 * The sound that is played when the enemy is hit by an lweapon.

int DrawXOffset;
 * The horizontal draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int DrawYOffset;
 * The vertical draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int DrawZOffset;
 * The depth draw offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int HitXOffset;
 * The horizontal hitbox offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitYOffset;
 * The vertical hitbox offset of the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitWidth;
 * The hitbox width (X component), in pixels, for the enemy.
 * Note: SizeFlag[??] must be enabled for this to function.

int HitHeight;
 * The hitbox height (Y component), in pixels, for the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.

int HitZHeight;
 * The hitbox height (Z component), in pixels, for the enemy. 
 * Note: SizeFlag[??] must be enabled for this to function.
	
int TileWidth;
 * The drawn width (X component) of the enemy in increments of one tile.
 * Note: SizeFlag[??] must be enabled for this to function.
	
int TileHeight;
 * The drawn height (Y component) of the enemy in increments of one tile.
 * Note: SizeFlag[??] must be enabled for this to function.
	
int WeaponSprite;
 * The sprite used to draw the enemy weapon.

int Defense[42];
 * The defense categories for the enemy.

int SizeFlag[2];
 * A set of flags that determine if the values for the Enemy Editor 'Size' tab
 * 	are rendered by the engine.

int Attributes[32];
 * The 'Misc. Attributes' of the enemy; now 32 of these; and datatype-insensitive.

bool Shield[5];
 * The shield status of the enemy.
 * [0] through [3] correspond to DIR* constants.
 * [4] corresponds to ???.

int FrozenTile;
 * The base tile used to draw the enemy, when the enemy is frozen solid. //Not yet implemented in-engine.

int FrozenCSet;
 * The CSet value used to render the enemy, when the enemy is frozen solid. //Not yet implemented in-engine.

t/b/a
//int Movement[32]
//* The Movement Pattern values used by the enemy.
//int WeaponMovement[32]
//* The Weapon Movement Pattern values used by the enemy.

//FireSFX
//* The sound played when the enemy uses its weapon.



////////////////////
///  spritedata  ///
////////////////////

/*
The spritedata datatype allows the user to load and manipulate weapon sprite struct
data, and to r/w that information.

Like itemdata, this persists only until the quest exits.

To use spritedata, you must declare a spritedata typed pointer, then load a sprite ID
to that pointer. 

spritedata sd = Game->LoadSpriteData(1); // Load weapon sprite 1 to the pointer 'sd'.

From here, you may access the member functions, and variables as normal:

sd->Tile = 600;

*/

int Tile;
 * The tile used by the weapon sprite.

int Misc;
 * The Misc Type. (or is this Type?)

int CSet;
 * The CSet used by the sprite.

int Frames;
 * The number of frames in the animation cycle.

int Speed;
 * The speed of the animation cycle.

int Type;
 * The Misc Type. (or is this Misc?)

//Where are Flash, and Flags?! -Z

//////////////////
///  dropdata  ///
//////////////////

t/b/a

////////////////
///  bitmap  ///
////////////////

int Width;
 * Returns the width of the bitmap, in pixels. 
 * READ-ONLY. Bitmaps cannot be resized by writing to this. 
 
int Height;
 * Returns the height of the bitmap, in pixels. 
 * READ-ONLY. Bitmaps cannot be resized by writing to this. 

float GetPixel(int x, int y);
 * Returns the palette index value of a pixel on the current bitmap pointer (set by Game->LoadBitmapID).

void Create(int layer, int width, int height);
 * Creates a bitmap on an already-initialised bitmap pointer, with a size of height, width.
 * Destroys any existing bitmap ont hat pointer before creating a new one. 
 * You can use this in conjunction with Game->AllocateBitmap(), or to destroy an existing bitmap and 
 * create a new one.
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT clear a specific 'layer' of a bitmap. 
 *       Layers in ZC are only an expression of drawing order/sequence!
 
void Clear(int layer);
 * Clears the bitmap to colour 0. 
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT write out a specific 'layer' of a bitmap.
 *        Layers in ZC are only an expression of drawing order/sequence!
 
void Read(int layer, "filename");
 * Reads a valid graphic file into a bitmap pointer.
 * Use Game->AllocateBitmap() to prime the pointer first, if it is uninitialised.
 * If the filename provided is invalid (e.g., the file is missing), the pointer
 * will be initialised with a blank bitmap at a size of 256x176.
 
void Write(int layer, "filename", bool allow_overwrite);
 * Writes a bitmap out as a graphic file.
 * This supports the following formats/extensions:
 * .png, .gif, .pcx, .tgx, and .bmp. 
 * The provided filename string MUST include one of these extensions, as this
 * both sets the output filetype, and validates the write.
 * Any other extension, or a lack of a valid extension will result in
 * logging an error and failing to write the file.
 * Will not replace an existing file unless bool_overwrite is true.
 * Will fail on an uninitialised pointer. 
 * Note: The 'layer' arg in this function is exclusively for ordering. 
 *       This WILL NOT write out a specific 'layer' of a bitmap.
 *        Layers in ZC are only an expression of drawing order/sequence!

void Blit	( int layer, 
			bitmap target, 
			int source_x, int source_y, int source_w, int source_h, 
			int dest_x, int dest_y, int dest_w, int dest_h, 
			float rotation, int cx, int cy, int mode, int lit,  bool mask);
			
 * BLITS THE BITMAP ON POINTER 'b' TO A TARGET BITMAP. 
 * As DrawBitmapEx(), except that it draws FROM an initialised bitmap pointer,
 * TO a target bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh
 *	as the argument to 'bitmap target'.
 * To draw to a user created bitmap, pass its pointer to 'bitmap target'.

void BlitTo ( int layer, 
			bitmap source, 
			int source_x, int source_y, int source_w, int source_h, 
			int dest_x, int dest_y, int dest_w, int dest_h, 
			float rotation, int cx, int cy, int mode, int lit,  bool mask);
			
 * BLITS ANOTHER BITMAP TO THE POINTER 'b'.
 * As DrawBitmapEx(), except that it draws TO an initialised bitmap pointer,
 * FROM a source bitmap, which may be a user-created bitmap, or it may be the screen.
 * To draw to the screen, or to one of the old system bitmaps, use the RT_* value from std_constants.zh
 *	as the argument to 'bitmap source'.
 * To draw from a user created bitmap, pass its pointer to 'bitmap source.

void Rectangle(int layer, 
			int x, int y, int x2, int y2, 
			int color, float scale, 
			int rx, int ry, int rangle, 
			bool fill, int opacity		);
 * Identical to Screen->Rectangle(), but it draws to a target bitmap.

void Circle(int layer, 
		int x, int y, int radius, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool fill, int opacity	);
 * Identical to Screen->Circle(), but it draws to a target bitmap.

void Arc(int layer, 
		int x, int y, int radius, int startangle, int endangle, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool closed, bool fill, int opacity	);
 * Identical to Screen->Arc(), but it draws to a target bitmap.

void Ellipse(int layer, 
		int x, int y, int xradius, int yradius, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool fill, int opacity);
 * Identical to Screen->Ellipse(), but it draws to a target bitmap.

void Line(int layer, 
		int x, int y, int xradius, int yradius, 
		int color, float scale, 
		int rx, int ry, int rangle, 
		bool fill, int opacity);
 * Identical to Screen->Line(), but it draws to a target bitmap.

void Spline(int layer, 
		int x1, int y1, int x2, int y2, #
		int x3, int y3,int x4, int y4, 
		int color, int opacity);
 * Identical to Screen->Spline(), but it draws to a target bitmap.

void PutPixel(int layer, int x, int y, 
		int color, 
		int rx, int ry, int rangle, 
		int opacity);
 * Identical to Screen->PutPixel(), but it draws to a target bitmap.

void DrawCharacter(int layer, int x, int y, 
			int font, int color, int background_color, 
			int width, int height, 'char', 
			int opacity );
 * Identical to Screen->DrawCharacter(), but it draws to a target bitmap.

void DrawInteger(int layer, int x, int y, 
			int font, int color, int background_color, 
			int width, int height, int number, int number_decimal_places, 
			int opacity);
 * Identical to Screen->DrawInteger(), but it draws to a target bitmap.

void DrawTile(int layer, int x, int y, 
		int tile, int blockw, int blockh, 
		int cset, int xscale, int yscale, 
		int rx, int ry, int rangle, 
		int flip, 
		bool transparency, int opacity);
 * Identical to Screen->DrawTile(), but it draws to a target bitmap.

void DrawComboint layer, int x, int y, 
		int combo, int w, int h, 
		int cset, int xscale, int yscale, 
		int rx, int ry, int rangle, 
		int frame, int flip, 
		bool transparency, int opacity);
 * Identical to Screen->DrawCombo(), but it draws to a target bitmap.

void DrawString(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			"string", 
			int opacity );
 * Identical to Screen->DrawString(), but it draws to a target bitmap.

void DrawLayer(int layer, 
			int source_map, int source_screen, int source_layer, 
			int x, int y, float rotation, int opacity);
 * Identical to Screen->DrawLayer(), but it draws to a target bitmap.

Quad( int layer, 
	int x1, int y1, int x2, int y2, 
	int x3, int y3, int x4, int y4,
	int w, int h, int cset, int flip, 
	int texture, int render_mode, bitmap render_source)
 * Identical to Screen->Quad(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture.
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile. 

void Triangle	( int layer, 
			int x1, int y1, int x2, 
			int y2, int x3, int y3,
			int w, int h, int cset, 
			int flip, int texture, 
			int render_mode, bitmap render_source);
			
 * Identical to Screen->Triangle(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile. 

void Quad3D( int layer, 
			int pos[12], int uv[8], int cset[4], int size[2], 
			int flip, int texture, int polytype, bitmap render_source );
 * Identical to Screen->Quad(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile.

void Triangle3D( int layer, 
			int pos[9], int uv[6], int csets[3], int size[2], 
			int flip, int tile, int polytype, bitmap render_source);
			
 * Identical to Screen->Triangle(), but it draws to a target bitmap, and you can specify a bitmap as your texture.
 * Pass the bitmap pointer that you want to use to 'bitmap render_source'.
 * If you do not wish to use a bitmap as a texture, pass NULL to the arg 'bitmap render_source'.
 * Use PT_TEXTURE or a similar polytype, to render your bitmap as a texture. 
 * For bitmap textures, specify the exact height and width of the texture as args 'w' and 'h'.
 * If rendering a bitmap as a texture, the 'h' and 'w' args need not be a power of 2. 
 * If `bitmap render_source` != NULL, then it will use this as the texture, instead of a tile or combo.
 * If the pointer supplied to render_source is invalid (contains no data), then
 * this function will default to using a tile.

void FastTile(int layer, int x, int y, 
		int tile, int cset, 
		int opacity );
 * Identical to Screen->FastTile(), but it draws to a target bitmap.

void FastCombo(int layer, int x, int y, 
		int combo, int cset, 
		int opacity );
 * Identical to Screen->FastCombo(), but it draws to a target bitmap.

void Polygon(int layer, int num_points, int vertices[], int colour, int transparency);
	ZASM: POLYGON
 * Draws a polygon to the bitmap, with a number of points specified as int points,
 * with vertices supplied as an array. 
 
 
void DrawScreen	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws an entire screen from screen on map on the specified layer of the bitmap at (x,y).
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenSolid	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the solidity mask entire screen from screen on map on the specified layer of the bitmap at (x,y) in colour index 1.
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenSolidity	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the solidity value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboS[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.
 
void DrawScreenComboTypes	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the combo type value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboT[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenComboFlags	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the combo flag value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboF[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.

void DrawScreenComboIFlags	(int layer, 
			int map, int source_screen, 
			int x, int y, float rotation);
			
 * Draws the combo inh.flag value for each combo position of an entire screen from screen on map on 
 * the specified layer of the bitmap at (x,y).
 * Each combo position will be drawn in the palette index equal to its value as ComboI[].
 * If rotation is not zero, it(the entire screen) will rotate about its center.


	
// Destroy()
// All screen drawing instructions.
// Resize?
// int Depth (read-only)
// Transform() 
// RenderTo(target, mode, args[])
// RenderFrom(target, mode, args[])


t/b/a

//////////////////
///  ponddata  ///
//////////////////

t/b/a

//////////////////
///  warpring  ///
//////////////////

t/b/a

/////////////////
///  doorset  ///
/////////////////

t/b/a

////////////////////
///  misccolors  ///
////////////////////

t/b/a

/////////////////
///  rgbdata  ///
/////////////////

t/b/a

/////////////////
///  palette  ///
/////////////////

t/b/a

////////////////
///  zcmidi  ///
////////////////

t/b/a

//////////////////
///  palcycle  ///
//////////////////

t/b/a

//////////////////
///  gamedata  ///
//////////////////

t/b/a

////////////////
///  cheats  ///
////////////////

t/b/a

/////////////////
///  Debug->  ///
/////////////////

untyped NULL;
untyped Null;
untyped Null();
untyped NULL();
 * You may assign this function to any datatype to clear it to NULL.
 * Example:
lweapon l = Screen->LoadLWeapon(16);
l->Dir = DIR_UP;
l = NULL(); // Clear the pointer to NULL.

float D[256];
 * This is the value of the ri->d[] registers. 
 * These vary depending on the function, or the instruction.
 * For variable access, SETTER: ri->d[0] is the value being passed to the variable.
 * For variable access, GETTER: ri->d[0] *MIGHT BE* the value read from ther variable. (Need to verify.)
 * For array access, SETTER: ri->d[0] is the array index, and ri->d[1] is the value.
 * For array access, GETTER: ri->d[0] is the array index. Not sure on the RVal at this time.

 * For functions, ri->d[n] are the args passed to the functions.
 * 	Typically, the order is ri->d[0] for the first parameter, and each additional param is one index higher.
 *	Some functions might pop values in weird ways. 
 *	It should be possible to purely write functions as SETTER and GETTER types, so that their params
 * 	are simply the ri->d[] values, in order. 

 * Script drawing commands use sdci[] (&script_drawing_commands[n1][n2]), which is different.
 * Their params should still be available via ri->d[], but some values, may not. 
 * 	The frirst param for any script drawing instruction is the BITMAP that it uses. 
 * 	For bitmap-> pointer drawing commands, the bitmap ID is ri->bitmapref, set by Game->LoadBitmapID().
 * 	Otherwise, the BITMAP pointer is set by SetRenderTarget(), qand held in sdci[18].
 *	The other params follow, as inputs from the instruction (function params passed to it).
 *	last, the playfield offsets typically follow the function params.
 * 	Of these, on;y the sdci[] values would be available to ri->d[], if nothing eats them beforehand.

GDR[256]
Debug->GetFFCPointer(), SetFFCPointer(), GetItemPointer(), SetItemPointer(), GetItemdataPointer(), SetItemdataPointer()
	GetNPCPointer(), SetNPCPointer(), GetLWeaponPointer(), SetLWeaponPointer(), GetEWeaponPointer(),
	SetEWeaponPointer(), RefFFC, RefItem, RefItemdata, RefLWeapon, RefEWeapon, RefNPC, SP
,



/************************************************************************************************************/
Game->DEBUGGING: These might find their way into namespace Debug-> instead of Game-> in the future. 
/************************************************************************************************************/	

int RefFFC; 				ZASM Instruction:
					REFFFC
	/**
	* Returns the present ffc reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefItem; 				ZASM Instruction:
					REFITEM
	/**
	* Returns the present item reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefItemdata; 			ZASM Instruction:
					REFIDATA
	/**
	* Returns the present itemdata reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefLWeapon; 			ZASM Instruction:
					REFLWPN
	/**
	* Returns the present lweapon reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefEWeapon; 			ZASM Instruction:
					REFEWPN
	/**
	* Returns the present eweapon reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int RefNPC; 				ZASM Instruction:
					REFNPC
	/**
	* Returns the present npc reference from the stack. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:
	
/************************************************************************************************************/	

int SP; 				ZASM Instruction:
					SP
	/**
	* Returns the value of the stack pointer. FOR DEBUGGING ONLY!
	* THIS WILL BE DISABLED IN RELEASE BUILDS !
	*/ Example Use:

**********************************************************************************************************/

SetRenderSource(int target, int x, int y, int w, int h)

/************************************************************************************************************/

//To add:
Game->Freeze(int type) or Game->Suspend() 
datatype->Create(), Load(), Destroy()
